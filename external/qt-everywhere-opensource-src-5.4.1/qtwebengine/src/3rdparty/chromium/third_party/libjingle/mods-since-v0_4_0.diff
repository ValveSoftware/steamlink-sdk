Only in libjingle-0.4.0: Makefile.in
diff -r libjingle-0.4.0/README libjingle/files/README
1,39c1,39
< Libjingle
< 
< Libjingle is a set of components provided by Google to interoperate with Google
< Talk's peer-to-peer and voice capabilities. This package will create several
< static libraries you may link to your project as needed.
< 
< -talk               - No source files in talk/, just these subdirectories
< |-base              - Contains basic low-level portable utility functions for 
< |                     things like threads and sockets
< |-p2p               - The P2P stack
<   |-base            - Base p2p functionality
<   |-client          - Hooks to tie it into XMPP
< |-session           - Signaling
<   |-phone           - Signaling code specific to making phone calls
< |-third_party       - Components that aren't ours
<   |-mediastreamer   - Media components for dealing with sound hardware and 
<   |                   voice codecs
< |-xmllite           - XML parser
< |-xmpp              - XMPP engine
< 
< In addition, this package contains two examples in talk/examples which 
< illustrate the basic concepts of how the provided classes work.
< 
< The xmllite component of libjingle depends on expat. You can download expat 
< from http://expat.sourceforge.net/.
< 
< mediastreamer, the media components used by the example applications depend on
< the oRTP and iLBC components from linphone, which can be found at 
< http://www.linphone.org. Linphone, in turn depends on GLib, which can be found
< at http://www.gtk.org. This GLib dependency should be removed in future 
< releases.
< 
< Building Libjingle
< 
< Once the dependencies are installed, run ./configure. ./configure will return
< an error if it failed to locate the proper dependencies. If ./configure
< succeeds, run 'make' to build the components and examples.
< 
< When the build is complete, you can run the call example from 
---
> Libjingle
> 
> Libjingle is a set of components provided by Google to interoperate with Google
> Talk's peer-to-peer and voice capabilities. This package will create several
> static libraries you may link to your project as needed.
> 
> -talk               - No source files in talk/, just these subdirectories
> |-base              - Contains basic low-level portable utility functions for 
> |                     things like threads and sockets
> |-p2p               - The P2P stack
>   |-base            - Base p2p functionality
>   |-client          - Hooks to tie it into XMPP
> |-session           - Signaling
>   |-phone           - Signaling code specific to making phone calls
> |-third_party       - Components that aren't ours
>   |-mediastreamer   - Media components for dealing with sound hardware and 
>   |                   voice codecs
> |-xmllite           - XML parser
> |-xmpp              - XMPP engine
> 
> In addition, this package contains two examples in talk/examples which 
> illustrate the basic concepts of how the provided classes work.
> 
> The xmllite component of libjingle depends on expat. You can download expat 
> from http://expat.sourceforge.net/.
> 
> mediastreamer, the media components used by the example applications depend on
> the oRTP and iLBC components from linphone, which can be found at 
> http://www.linphone.org. Linphone, in turn depends on GLib, which can be found
> at http://www.gtk.org. This GLib dependency should be removed in future 
> releases.
> 
> Building Libjingle
> 
> Once the dependencies are installed, run ./configure. ./configure will return
> an error if it failed to locate the proper dependencies. If ./configure
> succeeds, run 'make' to build the components and examples.
> 
> When the build is complete, you can run the call example from 
41,57c41,57
< 
< Relay Server
< 
< Libjingle will also build a relay server that may be used to relay traffic
< when a direct peer-to-peer connection could not be established. The relay
< server will build in talk/p2p/base/relayserver and will listen on UDP
< ports 5000 and 5001. See the Libjingle Developer Guide at 
< http://code.google.com/apis/talk/index.html for information about configuring
< a client to use this relay server.
< 
< STUN Server
< 
< Lastly, Libjingle builds a STUN server which implements the STUN protocol for
< Simple Traversal of UDP over NAT. The STUN server is built as
< talk/p2p/base/stunserver and listens on UDP port 7000. See the Libjingle
< Developer Guide at http://code.google.com/apis/talk/index.html for information
< about configuring a client to use this STUN server.
---
> 
> Relay Server
> 
> Libjingle will also build a relay server that may be used to relay traffic
> when a direct peer-to-peer connection could not be established. The relay
> server will build in talk/p2p/base/relayserver and will listen on UDP
> ports 5000 and 5001. See the Libjingle Developer Guide at 
> http://code.google.com/apis/talk/index.html for information about configuring
> a client to use this relay server.
> 
> STUN Server
> 
> Lastly, Libjingle builds a STUN server which implements the STUN protocol for
> Simple Traversal of UDP over NAT. The STUN server is built as
> talk/p2p/base/stunserver and listens on UDP port 7000. See the Libjingle
> Developer Guide at http://code.google.com/apis/talk/index.html for information
> about configuring a client to use this STUN server.
diff -r libjingle-0.4.0/README.win libjingle/files/README.win
1,24c1,24
< 1. Install Visual C++ Express 2005.  It is free from this link:
<    http://msdn.microsoft.com/vstudio/express/visualc/
< 
< 2. Install the platform SDK and integrate it into VC++ express
<    http://msdn.microsoft.com/vstudio/express/visualc/usingpsdk/
< 
< 3. Download and install binary package for expat:
<    http://sourceforge.net/project/showfiles.php?group_id=10127&package_id=11277
< 
< 4. Update the Visual C++ directories in the Projects and Solutions section in the Options dialog box
<    Library files: C:\expat-VERSION\StaticLibs
<    Include files: C:\expat-VERSION\Source\Lib
<    where VERSION is the version of expat you've downoaded
< 
< 5. Unzip the libjingle files and open the solution.
< 
< 6. If you wish to build the call example with GIPS Voice Engine Lite, download Voice Engine Lite from http://developer.globalipsound.com
< 
< 7. Extract the Interface and Library directories from the Voice Engine Lite zip file into talk\third_party\gips
< 
< 8. Open talk\third_party\gips\expiration.h and set the GIPS_EXPIRATION #defines to the expiration date provided by GIPS and remove the #error directive
< 
< 9. Build the solution
< 
---
> 1. Install Visual C++ Express 2005.  It is free from this link:
>    http://msdn.microsoft.com/vstudio/express/visualc/
> 
> 2. Install the platform SDK and integrate it into VC++ express
>    http://msdn.microsoft.com/vstudio/express/visualc/usingpsdk/
> 
> 3. Download and install binary package for expat:
>    http://sourceforge.net/project/showfiles.php?group_id=10127&package_id=11277
> 
> 4. Update the Visual C++ directories in the Projects and Solutions section in the Options dialog box
>    Library files: C:\expat-VERSION\StaticLibs
>    Include files: C:\expat-VERSION\Source\Lib
>    where VERSION is the version of expat you've downoaded
> 
> 5. Unzip the libjingle files and open the solution.
> 
> 6. If you wish to build the call example with GIPS Voice Engine Lite, download Voice Engine Lite from http://developer.globalipsound.com
> 
> 7. Extract the Interface and Library directories from the Voice Engine Lite zip file into talk\third_party\gips
> 
> 8. Open talk\third_party\gips\expiration.h and set the GIPS_EXPIRATION #defines to the expiration date provided by GIPS and remove the #error directive
> 
> 9. Build the solution
> 
Only in libjingle-0.4.0: aclocal.m4
Only in libjingle-0.4.0: config.guess
diff -r libjingle-0.4.0/config.h libjingle/files/config.h
14c14
< #define HAVE_ALSA_ASOUNDLIB_H 1
---
> /* #undef HAVE_ALSA_ASOUNDLIB_H */
23c23
< #define HAVE_GLIB 1
---
> /* #undef HAVE_GLIB */
38c38
< #define HAVE_ORTP 1
---
> /* #undef HAVE_ORTP */
41c41
< #define HAVE_SPEEX 1
---
> /* #undef HAVE_SPEEX */
47c47
< #define HAVE_SPEEX_SPEEX_H 1
---
> /* #undef HAVE_SPEEX_SPEEX_H */
71c71
< #define LINUX 1
---
> /* #undef LINUX */
113c113
< #define __ALSA_ENABLED__ 1
---
> /* #undef __ALSA_ENABLED__ */
Only in libjingle-0.4.0: config.h.in
Only in libjingle-0.4.0: config.sub
Only in libjingle-0.4.0: configure
Only in libjingle-0.4.0: depcomp
Only in libjingle-0.4.0: install-sh
Only in libjingle-0.4.0: ltmain.sh
Only in libjingle-0.4.0: missing
Only in libjingle-0.4.0/talk: Makefile.in
Only in libjingle-0.4.0/talk/base: Makefile.in
diff -r libjingle-0.4.0/talk/base/asynchttprequest.cc libjingle/files/talk/base/asynchttprequest.cc
73c73
<     talk_base::SSLAdapter * ssl_adapter = talk_base::SSLAdapter::Create(socket);
---
>     talk_base::SSLAdapter * ssl_adapter = factory_->CreateSSLAdapter(socket);
75c75,81
<     ssl_adapter->StartSSL(hostname_.c_str(), true);
---
>     int error = ssl_adapter->StartSSL(hostname_.c_str(),
>                                       use_restartable_ssl_sockets_);
>     if (error != 0) {
>       LOG(LS_WARNING) << "Could not start SSL; error = " << error;
>       delete ssl_adapter;
>       return 0;
>     }
diff -r libjingle-0.4.0/talk/base/asynchttprequest.h libjingle/files/talk/base/asynchttprequest.h
23,24c23
<   public SignalThread,
<   public sigslot::has_slots<> {
---
>   public SignalThread {
106c105,106
<       binary_mode_(false), agent_(user_agent) { }
---
>       binary_mode_(false), agent_(user_agent),
>       ignore_bad_cert_(false), use_restartable_ssl_sockets_(false) { }
114a115,120
>   bool use_restartable_ssl_sockets() const {
>     return use_restartable_ssl_sockets_;
>   }
>   void SetUseRestartableSSLSockets(bool use_restartable_ssl_sockets) {
>     use_restartable_ssl_sockets_ = use_restartable_ssl_sockets;
>   }
133a140
>   bool use_restartable_ssl_sockets_;
diff -r libjingle-0.4.0/talk/base/asynctcpsocket.cc libjingle/files/talk/base/asynctcpsocket.cc
31a32,33
> #include <cstring>
> 
diff -r libjingle-0.4.0/talk/base/autodetectproxy.cc libjingle/files/talk/base/autodetectproxy.cc
29c29
< #include "talk/base/httpcommon.h"
---
> #include "talk/base/httpcommon-inl.h"
114c114
<   Thread::Current()->MessageQueue::Stop();
---
>   Thread::Current()->Quit();
diff -r libjingle-0.4.0/talk/base/autodetectproxy.h libjingle/files/talk/base/autodetectproxy.h
22c22
< class AutoDetectProxy : public SignalThread, public sigslot::has_slots<> {
---
> class AutoDetectProxy : public SignalThread {
diff -r libjingle-0.4.0/talk/base/base64.h libjingle/files/talk/base/base64.h
26,27c26,27
<   static const std::string Base64::Base64Table;
<   static const std::string::size_type Base64::DecodeTable[];
---
>   static const std::string Base64Table;
>   static const std::string::size_type DecodeTable[];
diff -r libjingle-0.4.0/talk/base/common.h libjingle/files/talk/base/common.h
54c54
< #define stdmax(x,y) max(x,y)
---
> #define stdmax(x,y) _max(x,y)
114,119d113
< // A macro to disallow the evil copy constructor and operator= functions
< // This should be used in the private: declarations for a class
< #define DISALLOW_EVIL_CONSTRUCTORS(TypeName)    \
<   TypeName(const TypeName&);                    \
<   void operator=(const TypeName&)
< 
diff -r libjingle-0.4.0/talk/base/criticalsection.h libjingle/files/talk/base/criticalsection.h
39c39
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
41c41
< #endif  // _DEBUG
---
> #endif  // !defined(NDEBUG)
83c83
< public:
---
>  public:
85a86
>     pthread_mutexattr_init(&mutex_attribute);
87a89,90
>     pthread_mutexattr_destroy(&mutex_attribute);
>     TRACK_OWNER(thread_ = 0);
93a97
>     TRACK_OWNER(thread_ = pthread_self());
95a100
>     TRACK_OWNER(thread_ = 0);
98c103,110
< private:
---
> 
> #if CS_TRACK_OWNER
>   bool CurrentThreadIsOwner() const {
>     return pthread_equal(thread_, pthread_self());
>   }
> #endif  // CS_TRACK_OWNER
> 
>  private:
99a112
>   TRACK_OWNER(pthread_t thread_);
diff -r libjingle-0.4.0/talk/base/cryptstring.h libjingle/files/talk/base/cryptstring.h
30a31
> #include <string.h>
diff -r libjingle-0.4.0/talk/base/diskcache.cc libjingle/files/talk/base/diskcache.cc
43c43
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
45c45
< #else  // !_DEBUG
---
> #else  // defined(NDEBUG)
47c47
< #endif  // !_DEBUG
---
> #endif  // !defined(NDEBUG)
231c231
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
238c238
< #endif  // _DEBUG
---
> #endif  // !defined(NDEBUG)
diff -r libjingle-0.4.0/talk/base/diskcache_win32.cc libjingle/files/talk/base/diskcache_win32.cc
38c38
<       entry->streams = max(entry->streams, index + 1);
---
>       entry->streams = _max(entry->streams, index + 1);
diff -r libjingle-0.4.0/talk/base/helpers.cc libjingle/files/talk/base/helpers.cc
38a39
> #include <wincrypt.h>
diff -r libjingle-0.4.0/talk/base/host.cc libjingle/files/talk/base/host.cc
30a31
> #include <cstdlib>
diff -r libjingle-0.4.0/talk/base/httpclient.cc libjingle/files/talk/base/httpclient.cc
670a671
>         HttpAuthContext *context = context_.get();
676c677,678
<           *context_.use(), response, auth_method);
---
>           context, response, auth_method);
>         context_.reset(context);
diff -r libjingle-0.4.0/talk/base/httpcommon.h libjingle/files/talk/base/httpcommon.h
172c172
< inline const uint16 UrlDefaultPort(bool secure) {
---
> inline uint16 UrlDefaultPort(bool secure) {
diff -r libjingle-0.4.0/talk/base/logging.cc libjingle/files/talk/base/logging.cc
27a28
> #include <stdio.h>
76c77
< #if _DEBUG
---
> #if LOGGING
78c79
< #else  // !_DEBUG
---
> #else
80c81
< #endif  // !_DEBUG
---
> #endif
diff -r libjingle-0.4.0/talk/base/logging.h libjingle/files/talk/base/logging.h
67a68,69
> 
> #if defined(SAFE_TO_DEFINE_TALK_BASE_LOGGING_MACROS)
70a73
> #endif // defined(SAFE_TO_DEFINE_TALK_BASE_LOGGING_MACROS)
195a199
> #if defined(SAFE_TO_DEFINE_TALK_BASE_LOGGING_MACROS)
197c201
< #if defined(_DEBUG) && !defined(NDEBUG)
---
> #if !defined(NDEBUG)
290a295
> #endif  // defined(SAFE_TO_DEFINE_TALK_BASE_LOGGING_MACROS)
diff -r libjingle-0.4.0/talk/base/messagequeue.cc libjingle/files/talk/base/messagequeue.cc
98,99c98,99
<     new_ss = true;
<     ss_ = new PhysicalSocketServer();
---
>     default_ss_.reset(new PhysicalSocketServer());
>     ss_ = default_ss_.get();
103a104,107
>   // The signal is done from here to ensure
>   // that it always gets called when the queue
>   // is going away.
>   SignalQueueDestroyed();
108,109d111
<   if (new_ss)
<     delete ss_;
113,115d114
<   if (new_ss)
<     delete ss_;
<   new_ss = false;
119c118
< void MessageQueue::Stop() {
---
> void MessageQueue::Quit() {
124c123
< bool MessageQueue::IsStopping() {
---
> bool MessageQueue::IsQuitting() {
diff -r libjingle-0.4.0/talk/base/messagequeue.h libjingle/files/talk/base/messagequeue.h
35a36
> #include "talk/base/scoped_ptr.h"
162,164c163,164
< 
<   virtual void Stop();
<   virtual bool IsStopping();
---
>   virtual void Quit();
>   virtual bool IsQuitting();
188a189,192
>   // When this signal is sent out, any references to this queue should
>   // no longer be used.
>   sigslot::signal0<> SignalQueueDestroyed;
> 
192a197,198
>   // If a server isn't supplied in the constructor, use this one.
>   scoped_ptr<SocketServer> default_ss_;
diff -r libjingle-0.4.0/talk/base/natserver.cc libjingle/files/talk/base/natserver.cc
28a29
> #include <cstring>
diff -r libjingle-0.4.0/talk/base/natsocketfactory.cc libjingle/files/talk/base/natsocketfactory.cc
29a30
> #include <cstring>
diff -r libjingle-0.4.0/talk/base/openssladapter.cc libjingle/files/talk/base/openssladapter.cc
619c619
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
707c707
< #if _DEBUG
---
> #if !defined(NDEBUG)
736c736
< #endif  // _DEBUG
---
> #endif  // !defined(NDEBUG)
740c740
< #if _DEBUG
---
> #if !defined(NDEBUG)
798c798
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
diff -r libjingle-0.4.0/talk/base/openssladapter.h libjingle/files/talk/base/openssladapter.h
72c72
< #if _DEBUG
---
> #if !defined(NDEBUG)
74c74
< #endif  // !_DEBUG
---
> #endif  // !defined(NDEBUG)
diff -r libjingle-0.4.0/talk/base/physicalsocketserver.cc libjingle/files/talk/base/physicalsocketserver.cc
61a62
> #include "talk/base/winsock_initializer.h"
67,86d67
< #ifdef WIN32
< class WinsockInitializer {
< public:
<   WinsockInitializer() {
<     WSADATA wsaData;
<     WORD wVersionRequested = MAKEWORD(1, 0);
<     err_ = WSAStartup(wVersionRequested, &wsaData);
<   }
<   ~WinsockInitializer() {
<     WSACleanup();
<   }
<   int error() {
<     return err_;
<   }
< private:
<   int err_;
< };
< WinsockInitializer g_winsockinit;
< #endif
< 
124a106,108
> #ifdef WIN32
>     EnsureWinsockInit();
> #endif
187c171,177
<       addr2.Resolve(); // TODO: Do this async later?
---
>       // TODO: Do this async later?
>       if (!addr2.Resolve()) {
>         LOG(LS_ERROR) << "Resolving addr failed";
>         UpdateLastError();
>         Close();
>         return SOCKET_ERROR;
>       }
265a256,259
>       LOG(LS_WARNING) << "EOF from socket; deferring close event";
>       // Must turn this back on so that the select() loop will notice the close
>       // event.
>       enabled_events_ |= kfRead;
402a397
>   virtual bool IsDescriptorClosed() = 0;
452a448,451
>   virtual bool IsDescriptorClosed() {
>     return false;
>   }
> 
490a490,497
>   virtual bool IsDescriptorClosed() {
>     // We don't have a reliable way of distinguishing end-of-stream
>     // from readability.  So test on each readable call.  Is this
>     // inefficient?  Probably.
>     char ch;
>     return (0 == ::recv(s_, &ch, 1, MSG_PEEK));
>   }
> 
546a554,557
>   virtual bool IsDescriptorClosed() {
>     return false;
>   }
> 
916c927,931
<           ff |= kfRead;
---
>           if (pdispatcher->IsDescriptorClosed()) {
>             ff |= kfClose;
>           } else {
>             ff |= kfRead;
>           }
diff -r libjingle-0.4.0/talk/base/proxydetect.cc libjingle/files/talk/base/proxydetect.cc
205,206c205,206
<   const char* list = slist.c_str();
<   while (*list) {
---
>   const char* clist = slist.c_str();
>   while (*clist) {
208,209c208,209
<     if (isspace(*list)) {
<       ++list;
---
>     if (isspace(*clist)) {
>       ++clist;
214,217c214,217
<     const char * start = list;
<     if (const char * end = strchr(list, sep)) {
<       len = (end - list);
<       list += len + 1;
---
>     const char * start = clist;
>     if (const char * end = strchr(clist, sep)) {
>       len = (end - clist);
>       clist += len + 1;
219,220c219,220
<       len = strlen(list);
<       list += len;
---
>       len = strlen(clist);
>       clist += len;
diff -r libjingle-0.4.0/talk/base/schanneladapter.cc libjingle/files/talk/base/schanneladapter.cc
607c607
<   size_t read = min(cb, readable.size());
---
>   size_t read = _min(cb, readable.size());
diff -r libjingle-0.4.0/talk/base/scoped_ptr.h libjingle/files/talk/base/scoped_ptr.h
36,257c36
< namespace talk_base {
< 
< template <typename T>
< class scoped_ptr {
<  private:
< 
<   T* ptr;
< 
<   scoped_ptr(scoped_ptr const &);
<   scoped_ptr & operator=(scoped_ptr const &);
< 
<  public:
< 
<   typedef T element_type;
< 
<   explicit scoped_ptr(T* p = 0): ptr(p) {}
< 
<   ~scoped_ptr() {
<     typedef char type_must_be_complete[sizeof(T)];
<     delete ptr;
<   }
< 
<   void reset(T* p = 0) {
<     typedef char type_must_be_complete[sizeof(T)];
< 
<     if (ptr != p) {
<       delete ptr;
<       ptr = p;
<     }
<   }
< 
<   T& operator*() const {
<     assert(ptr != 0);
<     return *ptr;
<   }
< 
<   T* operator->() const  {
<     assert(ptr != 0);
<     return ptr;
<   }
< 
<   T* get() const  {
<     return ptr;
<   }
< 
<   void swap(scoped_ptr & b) {
<     T* tmp = b.ptr;
<     b.ptr = ptr;
<     ptr = tmp;
<   }
< 
<   T* release() {
<     T* tmp = ptr;
<     ptr = 0;
<     return tmp;
<   }
<   
<   T** accept() {
<     if (ptr) {
<       delete ptr;
<       ptr = 0;
<     }
<     return &ptr;
<   }
< 
<   T** use() {
<     return &ptr;
<   }
< };
< 
< template<typename T> inline
< void swap(scoped_ptr<T>& a, scoped_ptr<T>& b) {
<   a.swap(b);
< }
< 
< 
< 
< 
< //  scoped_array extends scoped_ptr to arrays. Deletion of the array pointed to
< //  is guaranteed, either on destruction of the scoped_array or via an explicit
< //  reset(). Use shared_array or std::vector if your needs are more complex.
< 
< template<typename T>
< class scoped_array {
<  private:
< 
<   T* ptr;
< 
<   scoped_array(scoped_array const &);
<   scoped_array & operator=(scoped_array const &);
< 
<  public:
< 
<   typedef T element_type;
< 
<   explicit scoped_array(T* p = 0) : ptr(p) {}
< 
<   ~scoped_array() {
<     typedef char type_must_be_complete[sizeof(T)];
<     delete[] ptr;
<   }
< 
<   void reset(T* p = 0) {
<     typedef char type_must_be_complete[sizeof(T)];
< 
<     if (ptr != p) {
<       delete [] ptr;
<       ptr = p;
<     }
<   }
< 
<   T& operator[](std::ptrdiff_t i) const {
<     assert(ptr != 0);
<     assert(i >= 0);
<     return ptr[i];
<   }
< 
<   T* get() const {
<     return ptr;
<   }
< 
<   void swap(scoped_array & b) {
<     T* tmp = b.ptr;
<     b.ptr = ptr;
<     ptr = tmp;
<   }
< 
<   T* release() {
<     T* tmp = ptr;
<     ptr = 0;
<     return tmp;
<   }
< 
<   T** accept() {
<     if (ptr) {
<       delete [] ptr;
<       ptr = 0;
<     }
<     return &ptr;
<   }
< };
< 
< template<class T> inline
< void swap(scoped_array<T>& a, scoped_array<T>& b) {
<   a.swap(b);
< }
< 
< // scoped_ptr_malloc<> is similar to scoped_ptr<>, but it accepts a
< // second template argument, the function used to free the object.
< 
< template<typename T, void (*FF)(void*) = free> class scoped_ptr_malloc {
<  private:
< 
<   T* ptr;
< 
<   scoped_ptr_malloc(scoped_ptr_malloc const &);
<   scoped_ptr_malloc & operator=(scoped_ptr_malloc const &);
< 
<  public:
< 
<   typedef T element_type;
< 
<   explicit scoped_ptr_malloc(T* p = 0): ptr(p) {}
< 
<   ~scoped_ptr_malloc() {
<     typedef char type_must_be_complete[sizeof(T)];
<     FF(static_cast<void*>(ptr));
<   }
< 
<   void reset(T* p = 0) {
<     typedef char type_must_be_complete[sizeof(T)];
< 
<     if (ptr != p) {
<       FF(static_cast<void*>(ptr));
<       ptr = p;
<     }
<   }
< 
<   T& operator*() const {
<     assert(ptr != 0);
<     return *ptr;
<   }
< 
<   T* operator->() const {
<     assert(ptr != 0);
<     return ptr;
<   }
< 
<   T* get() const {
<     return ptr;
<   }
< 
<   void swap(scoped_ptr_malloc & b) {
<     T* tmp = b.ptr;
<     b.ptr = ptr;
<     ptr = tmp;
<   }
< 
<   T* release() {
<     T* tmp = ptr;
<     ptr = 0;
<     return tmp;
<   }
< 
<   T** accept() {
<     if (ptr) {
<       FF(static_cast<void*>(ptr));
<       ptr = 0;
<     }
<     return &ptr;
<   }
< };
< 
< template<typename T, void (*FF)(void*)> inline
< void swap(scoped_ptr_malloc<T,FF>& a, scoped_ptr_malloc<T,FF>& b) {
<   a.swap(b);
< }
< 
< } // namespace talk_base
< 
< // TODO: get rid of this global using 
< using talk_base::scoped_ptr;
---
> #include "base/scoped_ptr.h"
diff -r libjingle-0.4.0/talk/base/signalthread.cc libjingle/files/talk/base/signalthread.cc
12a13,15
>   main_->SignalQueueDestroyed.connect(this,
>                                       &SignalThread::OnMainThreadDestroyed);
>   refcount_ = 1;
15a19,23
> void SignalThread::OnMainThreadDestroyed() {
>   EnterExit ee(this);
>   main_ = NULL;
> }
> 
19a28
>   EnterExit ee(this);
25a35
>   EnterExit ee(this);
27c37
<   if (kInit == state_) {
---
>   if (kInit == state_ || kComplete == state_) {
36c46,47
< void SignalThread::Destroy() {
---
> void SignalThread::Destroy(bool wait) {
>   EnterExit ee(this);
39,40c50,51
<     delete this;
<   } else if (kRunning == state_) {
---
>     refcount_--;
>   } else if (kRunning == state_ || kReleasing == state_) {
42,47c53,63
<     // A couple tricky issues here:
<     // 1) Thread::Stop() calls Join(), which we don't want... we just want
<     //    to stop the MessageQueue, which causes ContinueWork() to return false.
<     // 2) OnWorkStop() must follow Stop(), so that when the thread wakes up
<     //    due to OWS(), ContinueWork() will return false.
<     worker_.MessageQueue::Stop();
---
>     // OnWorkStop() must follow Quit(), so that when the thread wakes up due to
>     // OWS(), ContinueWork() will return false.
>     if (wait) {
>       // Release the thread's lock so that it can return from ::Run.
>       cs_.Leave(); 
>       worker_.Stop();
>       cs_.Enter();
>       refcount_--;
>     } else {
>       worker_.Quit();
>     }
54a71
>   EnterExit ee(this);
57c74
<     delete this;
---
>     refcount_--;
66a84
>   EnterExit ee(this);
71a90
>   EnterExit ee(this);
81a101,111
>       // Before signaling that the work is done, make sure that the worker
>       // thread actually is done. We got here because DoWork() finished and
>       // Run() posted the ST_MSG_WORKER_DONE message. This means the worker
>       // thread is about to go away anyway, but sometimes it doesn't actually
>       // finish before SignalWorkDone is processed, and for a reusable
>       // SignalThread this makes an assert in thread.cc fire.
>       //
>       // Calling Stop() on the worker ensures that the OS thread that underlies
>       // the worker will finish, and will be set to NULL, enabling us to call
>       // Start() again.
>       worker_.Stop();
85c115
<       delete this;
---
>       refcount_--;
92c122,127
<   main_->Post(this, ST_MSG_WORKER_DONE);
---
>   {
>     EnterExit ee(this);
>     if (main_) {
>       main_->Post(this, ST_MSG_WORKER_DONE);
>     }
>   }
diff -r libjingle-0.4.0/talk/base/signalthread.h libjingle/files/talk/base/signalthread.h
15a16,19
> //   Periodic tasks: Wait for SignalWorkDone, then eventually call Start()
> //    again to repeat the task. When the instance isn't needed anymore,
> //    call Release. DoWork, OnWorkStart and OnWorkStop are called again,
> //    on a new thread.
22c26
< class SignalThread : protected MessageHandler {
---
> class SignalThread : public sigslot::has_slots<>, protected MessageHandler {
35,36c39,41
<   // SignalWorkDone will not be signalled.
<   void Destroy();
---
>   // SignalWorkDone will not be signalled.  If wait is true, does not return
>   // until the thread is deleted.
>   void Destroy(bool wait);
53c58
<   
---
> 
57c62
<   // Context: Worker Thread.  Subclass should call periodically to
---
>   // Context: Worker Thread.  Subclass should call periodically to 
67c72
<   
---
>  
79a85,106
>   class EnterExit {
>     friend class SignalThread;
>    
>     SignalThread * t_;
>    
>     EnterExit(SignalThread * t) : t_(t) {
>       t_->cs_.Enter();
>       t_->refcount_ += 1;
>     }
>     ~EnterExit() {
>       bool d = (0 == (--(t_->refcount_)));
>       t_->cs_.Leave();
>       if (d)
>         delete t_;
>     }
>   };
> 
>   friend class EnterExit;
>  
>   CriticalSection cs_;
>   int refcount_;
> 
80a108
>   void OnMainThreadDestroyed();
84c112,118
<   enum State { kInit, kRunning, kComplete, kStopping, kReleasing } state_;
---
>   enum State {
>     kInit,            // Initialized, but not started
>     kRunning,         // Started and doing work
>     kReleasing,       // Same as running, but to be deleted when work is done
>     kComplete,        // Work is done
>     kStopping,        // Work is being interrupted
>   } state_;
diff -r libjingle-0.4.0/talk/base/sigslot.h libjingle/files/talk/base/sigslot.h
530c530
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
676c676
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
807c807
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
937c937
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
1067c1067
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
1199c1199
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
1331c1331
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
1463c1463
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
1596c1596
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
diff -r libjingle-0.4.0/talk/base/socket.h libjingle/files/talk/base/socket.h
77a78
> #undef ETIMEDOUT // remove pthread.h's definition
diff -r libjingle-0.4.0/talk/base/socketadapters.cc libjingle/files/talk/base/socketadapters.cc
43a44,45
> #include <cstring>
> 
diff -r libjingle-0.4.0/talk/base/socketaddress.cc libjingle/files/talk/base/socketaddress.cc
52c52
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
54c54
< #else // !_DEBUG
---
> #else // defined(NDEBUG)
56c56
< #endif // !_DEBUG
---
> #endif // !defined(NDEBUG)
diff -r libjingle-0.4.0/talk/base/socketfactory.h libjingle/files/talk/base/socketfactory.h
32a33
> #include "talk/base/ssladapter.h"
46a48,52
> 
>   // Wraps the given socket in an SSL adapter.
>   virtual SSLAdapter* CreateSSLAdapter(AsyncSocket* socket) {
>     return SSLAdapter::Create(socket);
>   }
diff -r libjingle-0.4.0/talk/base/socketpool.cc libjingle/files/talk/base/socketpool.cc
142d141
<     ASSERT(false);
189d187
<       ASSERT(false);
diff -r libjingle-0.4.0/talk/base/ssladapter.cc libjingle/files/talk/base/ssladapter.cc
34c34,35
< #define SSL_USE_OPENSSL 1
---
> // Turn off OpenSSL
> //#define SSL_USE_OPENSSL 1
84a86
> #if SSL_USE_OPENSSL || SSL_USE_SCHANNEL
85a88,90
> #else
>   return NULL;
> #endif
diff -r libjingle-0.4.0/talk/base/stream.cc libjingle/files/talk/base/stream.cc
27a28
> #include <stdio.h>
diff -r libjingle-0.4.0/talk/base/stringencode.cc libjingle/files/talk/base/stringencode.cc
34a35
> #include <stdlib.h>
525c526
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
575c576
< #endif  // _DEBUG
---
> #endif  // !defined(NDEBUG)
diff -r libjingle-0.4.0/talk/base/stringutils.cc libjingle/files/talk/base/stringutils.cc
72c72
< #if _DEBUG
---
> #if !defined(NDEBUG)
76c76
< #endif  // _DEBUG
---
> #endif  // !defined(NDEBUG)
diff -r libjingle-0.4.0/talk/base/stringutils.h libjingle/files/talk/base/stringutils.h
33a34
> #include <string.h>
87a89
> #if 0
93a96
> #endif
200,208d202
< size_t sprintfn(CTYPE* buffer, size_t buflen, const CTYPE* format, ...) {
<   va_list args;
<   va_start(args, format);
<   size_t len = vsprintfn(buffer, buflen, format, args);
<   va_end(args);
<   return len;
< }
< 
< template<class CTYPE>
218a213,221
> template<class CTYPE>
> size_t sprintfn(CTYPE* buffer, size_t buflen, const CTYPE* format, ...) {
>   va_list args;
>   va_start(args, format);
>   size_t len = vsprintfn(buffer, buflen, format, args);
>   va_end(args);
>   return len;
> }
> 
272c275
<   inline static const char* Traits<char>::empty_str() { return ""; }
---
>   inline static const char* empty_str() { return ""; }
diff -r libjingle-0.4.0/talk/base/task.cc libjingle/files/talk/base/task.cc
5c5
<  * Redistribution and use in source and binary forms, with or without 
---
>  * Redistribution and use in source and binary forms, with or without
8c8
<  *  1. Redistributions of source code must retain the above copyright notice, 
---
>  *  1. Redistributions of source code must retain the above copyright notice,
13c13
<  *  3. The name of the author may not be used to endorse or promote products 
---
>  *  3. The name of the author may not be used to endorse or promote products
17c17
<  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
---
>  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
19c19
<  * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
---
>  * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
23,24c23,24
<  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
<  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
---
>  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
>  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
141c141
<   if (aborted_ || done_)
---
>   if (done_)
150c150
<       Wake();  // to self-delete
---
>       GetRunner()->WakeTasks();
diff -r libjingle-0.4.0/talk/base/taskrunner.h libjingle/files/talk/base/taskrunner.h
63a64,68
>   bool HasPendingTimeoutTask() {
>     return next_timeout_task_ != NULL &&
>         next_timeout_task_->TimedOut();
>   }
> 
diff -r libjingle-0.4.0/talk/base/testclient.cc libjingle/files/talk/base/testclient.cc
29a30
> #include <cstring>
diff -r libjingle-0.4.0/talk/base/thread.cc libjingle/files/talk/base/thread.cc
100a101,105
> bool ThreadManager::ThreadActive(Thread *thread) {
>   CritScope cs(&crit_);
>   return(std::find(threads_.begin(), threads_.end(), thread) != threads_.end());
> }
> 
103a109
>   stopped_ = false;
124,125c130,135
<   pthread_create(&thread_, &attr, PreRun, this);
<   started_ = true;
---
>   CritScope cs(&started_crit_);
>   // Make sure Join() hasn't been called yet.
>   if (stopped_)
>     return;
>   if (pthread_create(&thread_, &attr, PreRun, this) == 0)
>       started_ = true;
128a139,140
>   CritScope cs(&started_crit_);
>   stopped_ = true;
131a144
>     started_ = false;
168a182,185
>   CritScope cs(&started_crit_);
>   // Make sure Join() hasn't been called yet.
>   if (stopped_)
>     return;
181a199,200
>   CritScope cs(&started_crit_);
>   stopped_ = true;
191a211,213
>   // Make sure the thread hasn't been deleted.
>   if (!g_thmgr.ThreadActive(thread))
>     return NULL;
207c229
<   MessageQueue::Stop();
---
>   MessageQueue::Quit();
329c351
<       return false;
---
>       return !IsQuitting();
diff -r libjingle-0.4.0/talk/base/thread.h libjingle/files/talk/base/thread.h
57a58
>   bool ThreadActive(Thread *thread);
134a136
>   CriticalSection started_crit_;
135a138
>   bool stopped_;
diff -r libjingle-0.4.0/talk/base/urlencode.cc libjingle/files/talk/base/urlencode.cc
0a1,2
> #include <stdlib.h>
> #include <string.h>
Only in libjingle-0.4.0/talk/base: win32socketserver.cc
Only in libjingle-0.4.0/talk/base: win32socketserver.h
Only in libjingle/files/talk/base: win32window.cc
diff -r libjingle-0.4.0/talk/base/winping.cc libjingle/files/talk/base/winping.cc
133c133
<   return sizeof(ICMP_ECHO_REPLY) + max(8UL, data_size);
---
>   return sizeof(ICMP_ECHO_REPLY) + _max((uint32)(8UL), data_size);
317c317
< } // namespace talk_base
\ No newline at end of file
---
> } // namespace talk_base
Only in libjingle/files/talk/base: winsock_initializer.cc
Only in libjingle/files/talk/base: winsock_initializer.h
Only in libjingle-0.4.0/talk: examples
Only in libjingle-0.4.0/talk: libjingle.sln
Only in libjingle-0.4.0/talk: libjingle.vcproj
Only in libjingle-0.4.0/talk: p2p
Only in libjingle-0.4.0/talk: session
Only in libjingle-0.4.0/talk: third_party
Only in libjingle-0.4.0/talk/xmllite: Makefile.in
diff -r libjingle-0.4.0/talk/xmllite/qname.cc libjingle/files/talk/xmllite/qname.cc
39c39
<   int result = ns.size() * 101;
---
>   int result = static_cast<int>(ns.size()) * 101;
diff -r libjingle-0.4.0/talk/xmllite/qname.h libjingle/files/talk/xmllite/qname.h
64d63
<       refcount_(1),
66c65,66
<       localPart_(local) {}
---
>       localPart_(local),
>       refcount_(1) {}
diff -r libjingle-0.4.0/talk/xmllite/xmlelement.cc libjingle/files/talk/xmllite/xmlelement.cc
88c88,89
<     pLastChild_(NULL) {
---
>     pLastChild_(NULL),
>     cdata_(false) {
97c98,99
<     pLastChild_(NULL) {
---
>     pLastChild_(NULL),
>     cdata_(false) {
125a128
>   cdata_ = elt.cdata_;
133c136,137
<   pLastChild_(NULL) {
---
>   pLastChild_(NULL),
>   cdata_(false) {
393a398,403
> XmlElement::AddCDATAText(const char * buf, int len) {
>   cdata_ = true;
>   AddParsedText(buf, len);
> }
> 
> void
diff -r libjingle-0.4.0/talk/xmllite/xmlelement.h libjingle/files/talk/xmllite/xmlelement.h
203a204,206
>   // Note: CDATA is not supported by XMPP, therefore using this function will
>   // generate non-XMPP compatible XML.
>   void AddCDATAText(const char * buf, int len);
217a221,222
>   bool IsCDATA() const { return cdata_; }
> 
228a234
>   bool cdata_;
diff -r libjingle-0.4.0/talk/xmllite/xmlparser.cc libjingle/files/talk/xmllite/xmlparser.cc
28,29d27
< #include "talk/xmllite/xmlparser.h"
< 
35a34
> #include "talk/xmllite/xmlconstants.h"
38c37
< #include "talk/xmllite/xmlconstants.h"
---
> #include "talk/xmllite/xmlparser.h"
119a119,121
>   context_.SetPosition(XML_GetCurrentLineNumber(expat_),
>                        XML_GetCurrentColumnNumber(expat_),
>                        XML_GetCurrentByteIndex(expat_));
127a130,132
>   context_.SetPosition(XML_GetCurrentLineNumber(expat_),
>                        XML_GetCurrentColumnNumber(expat_),
>                        XML_GetCurrentByteIndex(expat_));
134a140,142
>   context_.SetPosition(XML_GetCurrentLineNumber(expat_),
>                        XML_GetCurrentColumnNumber(expat_),
>                        XML_GetCurrentByteIndex(expat_));
168c176,180
<   if (XML_Parse(expat_, data, static_cast<int>(len), isFinal) != XML_STATUS_OK)
---
>   if (XML_Parse(expat_, data, static_cast<int>(len), isFinal) !=
>       XML_STATUS_OK) {
>     context_.SetPosition(XML_GetCurrentLineNumber(expat_),
>                          XML_GetCurrentColumnNumber(expat_),
>                          XML_GetCurrentByteIndex(expat_));
169a182
>   }
193c206,209
<     raised_(XML_ERROR_NONE) {
---
>     raised_(XML_ERROR_NONE),
>     line_number_(0),
>     column_number_(0),
>     byte_index_(0) {
247c263,285
< XmlParser::ParseContext::~ParseContext() {
---
> void
> XmlParser::ParseContext::SetPosition(XML_Size line, XML_Size column,
>                                      XML_Index byte_index) {
>   line_number_ = line;
>   column_number_ = column;
>   byte_index_ = byte_index;
> }
> 
> void
> XmlParser::ParseContext::GetPosition(unsigned long * line,
>                                      unsigned long * column,
>                                      unsigned long * byte_index) {
>   if (line != NULL) {
>     *line = static_cast<unsigned long>(line_number_);
>   }
> 
>   if (column != NULL) {
>     *column = static_cast<unsigned long>(column_number_);
>   }
> 
>   if (byte_index != NULL) {
>     *byte_index = static_cast<unsigned long>(byte_index_);
>   }
249a288
> XmlParser::ParseContext::~ParseContext() {
251a291
> }
diff -r libjingle-0.4.0/talk/xmllite/xmlparser.h libjingle/files/talk/xmllite/xmlparser.h
48a49,50
>   virtual void GetPosition(unsigned long * line, unsigned long * column,
>                            unsigned long * byte_index) = 0;
85a88,89
>     virtual void GetPosition(unsigned long * line, unsigned long * column,
>                              unsigned long * byte_index);
91a96
>     void SetPosition(XML_Size line, XML_Size column, XML_Index byte_index);
96a102,104
>     XML_Size line_number_;
>     XML_Size column_number_;
>     XML_Index byte_index_;
diff -r libjingle-0.4.0/talk/xmllite/xmlprinter.cc libjingle/files/talk/xmllite/xmlprinter.cc
46a47
>   void PrintCDATAText(const std::string & text);
134,136c135,141
<       if (pchild->IsText())
<         PrintBodyText(pchild->AsText()->Text());
<       else
---
>       if (pchild->IsText()) {
>         if (element->IsCDATA()) {
>           PrintCDATAText(pchild->AsText()->Text());
>         } else {
>           PrintBodyText(pchild->AsText()->Text());
>         }
>       } else
188a194,197
> void
> XmlPrinterImpl::PrintCDATAText(const std::string & text) {
>   *pout_ << "<![CDATA[" << text << "]]>";
> }
Only in libjingle-0.4.0/talk/xmpp: Makefile.in
Only in libjingle-0.4.0/talk/xmpp: constants.cc
Only in libjingle-0.4.0/talk/xmpp: constants.h
diff -r libjingle-0.4.0/talk/xmpp/jid.cc libjingle/files/talk/xmpp/jid.cc
33c33
< #include "talk/xmpp/constants.h"
---
> #include "talk/xmpp/xmppconstants.h"
diff -r libjingle-0.4.0/talk/xmpp/plainsaslhandler.h libjingle/files/talk/xmpp/plainsaslhandler.h
31d30
< #include "talk/xmpp/saslhandler.h"
32a32,34
> #include <string>
> 
> #include "talk/xmpp/saslhandler.h"
68a71,76
> 
>   virtual bool GetTlsServerInfo(const talk_base::SocketAddress& server,
>                                 std::string* tls_server_hostname,
>                                 std::string* tls_server_domain) {
>     return false;
>   }
diff -r libjingle-0.4.0/talk/xmpp/prexmppauth.h libjingle/files/talk/xmpp/prexmppauth.h
33d32
< #include "talk/xmpp/saslhandler.h"
64c63
< class PreXmppAuth : public SaslHandler {
---
> class PreXmppAuth {
diff -r libjingle-0.4.0/talk/xmpp/saslcookiemechanism.h libjingle/files/talk/xmpp/saslcookiemechanism.h
33c33
< #include "talk/xmpp/constants.h"
---
> #include "talk/xmpp/xmppconstants.h"
40,41c40,55
<   SaslCookieMechanism(const std::string & mechanism, const std::string & username, const std::string & cookie) :
<     mechanism_(mechanism), username_(username), cookie_(cookie) {}
---
>   SaslCookieMechanism(const std::string & mechanism,
>                       const std::string & username,
>                       const std::string & cookie,
>                       const std::string & token_service)
>     : mechanism_(mechanism),
>       username_(username),
>       cookie_(cookie),
>       token_service_(token_service) {}
> 
>   SaslCookieMechanism(const std::string & mechanism,
>                       const std::string & username,
>                       const std::string & cookie)
>     : mechanism_(mechanism),
>       username_(username),
>       cookie_(cookie),
>       token_service_("") {}
48a63,67
>     if (!token_service_.empty()) {
>       el->AddAttr(
>           QName(true, "http://www.google.com/talk/protocol/auth", "service"),
>           token_service_);
>     }
62a82
>   std::string token_service_;
diff -r libjingle-0.4.0/talk/xmpp/saslhandler.h libjingle/files/talk/xmpp/saslhandler.h
31a32,34
> #include <vector>
> 
> #include "talk/base/socketaddress.h"
53a57,63
> 
>   // Fills in the tls server hostname/domain to use for the given
>   // server (and returns true).  Return false if you want the defaults
>   // to be used.
>   virtual bool GetTlsServerInfo(const talk_base::SocketAddress& server,
>                                 std::string* tls_server_hostname,
>                                 std::string* tls_server_domain) = 0;
diff -r libjingle-0.4.0/talk/xmpp/saslmechanism.cc libjingle/files/talk/xmpp/saslmechanism.cc
30c30
< #include "talk/xmpp/constants.h"
---
> #include "talk/xmpp/xmppconstants.h"
diff -r libjingle-0.4.0/talk/xmpp/xmppclient.cc libjingle/files/talk/xmpp/xmppclient.cc
30c30
< #include "talk/xmpp/constants.h"
---
> #include "talk/xmpp/xmppconstants.h"
32a33
> #include "talk/xmpp/saslhandler.h"
68a70
>   scoped_ptr<SaslHandler> sasl_handler_;
93c95,99
< XmppClient::Connect(const XmppClientSettings & settings, const std::string & lang, AsyncSocket * socket, PreXmppAuth * pre_auth) {
---
> XmppClient::Connect(const XmppClientSettings & settings,
>                     const std::string & lang,
>                     AsyncSocket * socket,
>                     PreXmppAuth * pre_auth,
>                     SaslHandler * sasl_handler) {
113,125c119,125
<   //
<   // The talk.google.com server expects you to use "gmail.com" in the
<   // stream, and expects the domain certificate to be "gmail.com" as well.
<   // For all other servers, we leave the strings empty, which causes
<   // the jid's domain to be used.  "foo@example.com" -> stream to="example.com"
<   // tls certificate for "example.com"
<   //
<   // This is only true when using Gaia auth, so let's say if there's no preauth,
<   // we should use the actual server name
<   if ((settings.server().IPAsString() == buzz::STR_TALK_GOOGLE_COM ||
<       settings.server().IPAsString() == buzz::STR_TALKX_L_GOOGLE_COM) && 
<       pre_auth != NULL) {
<     d_->engine_->SetTlsServer(buzz::STR_GMAIL_COM, buzz::STR_GMAIL_COM);
---
>   if (sasl_handler) {
>     std::string tls_server_hostname, tls_server_domain;
>     if (sasl_handler->GetTlsServerInfo(settings.server(),
>                                        &tls_server_hostname,
>                                        &tls_server_domain)) {
>       d_->engine_->SetTlsServer(tls_server_hostname, tls_server_domain);
>     }
139a140
>   d_->sasl_handler_.reset(sasl_handler);
200a202,209
>   if (d_->sasl_handler_.get()) {
>     d_->engine_->SetSaslHandler(d_->sasl_handler_.release());
>   }
>   else {
>     d_->engine_->SetSaslHandler(new PlainSaslHandler(
>         d_->engine_->GetUser(), d_->pass_, d_->allow_plain_));
>   }
> 
209,210d217
<     d_->engine_->SetSaslHandler(new PlainSaslHandler(
<               d_->engine_->GetUser(), d_->pass_, d_->allow_plain_));
253,254d259
<   // transfer ownership of pre_auth_ to engine
<   d_->engine_->SetSaslHandler(d_->pre_auth_.release());
261a267,268
>     d_->pre_engine_error_ = XmppEngine::ERROR_SOCKET;
>     d_->pre_engine_subcode_ = d_->socket_->GetError();
347c354
< //#ifdef _DEBUG
---
> //#if !defined(NDEBUG)
375c382
< //#ifdef _DEBUG
---
> //#if !defined(NDEBUG)
diff -r libjingle-0.4.0/talk/xmpp/xmppclient.h libjingle/files/talk/xmpp/xmppclient.h
42a43
> class SaslHandler;
80c81,82
<                            PreXmppAuth * preauth);
---
>                            PreXmppAuth * preauth,
>                            SaslHandler * sasl_handler);
141c143
<   std::string XmppClient::GetStateName(int state) const {
---
>   std::string GetStateName(int state) const {
diff -r libjingle-0.4.0/talk/xmpp/xmppclientsettings.h libjingle/files/talk/xmpp/xmppclientsettings.h
31d30
< #include "talk/p2p/base/port.h"
32a32,45
> #include "talk/base/proxyinfo.h"
> 
> namespace cricket {
> 
> // This enum was taken from talk/p2p/base/port.h, which is the only
> // thing we actually need from the p2p directory.
> enum ProtocolType {
>   PROTO_UDP,
>   PROTO_TCP,
>   PROTO_SSLTCP,
>   PROTO_LAST = PROTO_SSLTCP
> };
> 
> }  // namespace cricket
59a73,75
>   void set_token_service(const std::string & token_service) {
>     token_service_ = token_service;
>   }
75a92
>   const std::string & token_service() const { return token_service_; }
93a111
>   std::string token_service_;
Only in libjingle/files/talk/xmpp: xmppconstants.cc
Only in libjingle/files/talk/xmpp: xmppconstants.h
diff -r libjingle-0.4.0/talk/xmpp/xmppengineimpl.cc libjingle/files/talk/xmpp/xmppengineimpl.cc
37c37
< #include "talk/xmpp/constants.h"
---
> #include "talk/xmpp/xmppconstants.h"
diff -r libjingle-0.4.0/talk/xmpp/xmppengineimpl_iq.cc libjingle/files/talk/xmpp/xmppengineimpl_iq.cc
32c32
< #include "talk/xmpp/constants.h"
---
> #include "talk/xmpp/xmppconstants.h"
diff -r libjingle-0.4.0/talk/xmpp/xmpplogintask.cc libjingle/files/talk/xmpp/xmpplogintask.cc
34c34
< #include "talk/xmpp/constants.h"
---
> #include "talk/xmpp/xmppconstants.h"
44c44
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
59c59
< #endif  // _DEBUG
---
> #endif  // !defined(NDEBUG)
103c103
< #if _DEBUG
---
> #if !defined(NDEBUG)
106c106
< #endif  // _DEBUG
---
> #endif  // !defined(NDEBUG)
218a219,221
>         auth->SetAttr(QN_GOOGLE_ALLOW_GENERATED_JID_XMPP_LOGIN, "true");
>         auth->SetAttr(QN_GOOGLE_AUTH_CLIENT_USES_FULL_BIND_RESULT, "true");
> 
diff -r libjingle-0.4.0/talk/xmpp/xmpplogintask.h libjingle/files/talk/xmpp/xmpplogintask.h
93c93
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
95c95
< #endif  // _DEBUG
---
> #endif  // !defined(NDEBUG)
diff -r libjingle-0.4.0/talk/xmpp/xmppstanzaparser.cc libjingle/files/talk/xmpp/xmppstanzaparser.cc
32c32
< #include "talk/xmpp/constants.h"
---
> #include "talk/xmpp/xmppconstants.h"
diff -r libjingle-0.4.0/talk/xmpp/xmpptask.cc libjingle/files/talk/xmpp/xmpptask.cc
31c31
< #include "talk/xmpp/constants.h"
---
> #include "talk/xmpp/xmppconstants.h"
40c40
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
88c88
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
174c174
< }
\ No newline at end of file
---
> }
diff -r libjingle-0.4.0/talk/xmpp/xmpptask.h libjingle/files/talk/xmpp/xmpptask.h
80c80
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
106,107c106,107
<   XmlElement *MakeIqResult(const XmlElement* query);
<   XmlElement *MakeIq(const std::string& type,
---
>   static XmlElement *MakeIqResult(const XmlElement* query);
>   static XmlElement *MakeIq(const std::string& type,
123c123
< #ifdef _DEBUG
---
> #if !defined(NDEBUG)
diff -r libjingle-0.4.0/talk/base/common.cc libjingle/files/talk/base/common.cc
62c62
< } // namespace talk_base
\ No newline at end of file
---
> } // namespace talk_base
diff -r libjingle-0.4.0/talk/base/httpbase.cc libjingle/files/talk/base/httpbase.cc
154c154
<         if (sscanf(value, "%d", &data_size_) != 1) {
---
>         if (sscanf(value, "%zu", &data_size_) != 1) {
diff -r libjingle-0.4.0/talk/base/httpcommon.cc libjingle/files/talk/base/httpcommon.cc
339c339
<                   &tval.tm_hour, &tval.tm_min, &tval.tm_sec, &zone)) {
---
>                   &tval.tm_hour, &tval.tm_min, &tval.tm_sec, zone)) {
472c472
<   uint32 vmajor, vminor;
---
>   unsigned long vmajor, vminor;
549,550c549,550
<   uint32 vmajor, vminor;
<   if ((sscanf(line, "HTTP/%lu.%lu %lu%n", &vmajor, &vminor, &scode, &pos) != 3)
---
>   unsigned long vmajor, vminor;
>   if ((sscanf(line, "HTTP/%lu.%lu %lu%zu", &vmajor, &vminor, &scode, &pos) != 3)
693c693
<     sprintf(buffer, "%d", time(0));
---
>     sprintf(buffer, "%ld", time(0));
diff -r libjingle-0.4.0/talk/base/httpcommon.h libjingle/files/talk/base/httpcommon.h
329c329
<   uint32 scode;
---
>   unsigned long scode;
diff -r libjingle-0.4.0/talk/base/diskcache.cc libjingle/files/talk/base/diskcache.cc
300c300
<   if (1 != sscanf(pathname.extension().c_str(), ".%u", index))
---
>   if (1 != sscanf(pathname.extension().c_str(), ".%zu", index))
diff -r libjingle-0.4.0/talk/base/logging.cc libjingle/files/talk/base/logging.cc
69c69
<   snprintf(buffer, sizeof(buffer), "0x%08lx", err);  
---
>   snprintf(buffer, sizeof(buffer), "0x%08x", err);  
diff -r libjingle-0.4.0/talk/base/socketadapters.cc libjingle/files/talk/base/socketadapters.cc
360,361c360,361
<     uint32 code;
<     if (sscanf(data, "HTTP/%*lu.%*lu %lu", &code) != 1) {
---
>     unsigned long code;
>     if (sscanf(data, "HTTP/%*u.%*u %lu", &code) != 1) {
