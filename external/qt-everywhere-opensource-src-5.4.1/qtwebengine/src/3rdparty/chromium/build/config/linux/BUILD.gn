# Copyright (c) 2013 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/config/linux/pkg_config.gni")
import("//build/config/sysroot.gni")
import("//build/config/ui.gni")

config("sdk") {
  if (sysroot != "") {
    cflags = [ "--sysroot=" + sysroot ]
    ldflags = [ "--sysroot=" + sysroot ]

    # Need to get some linker flags out of the sysroot.
    ldflags += [ exec_script("sysroot_ld_path.py",
        [ rebase_path("//build/linux/sysroot_ld_path.sh", root_build_dir),
          sysroot ],
        "value") ]
  }
}

pkg_config("dridrm") {
  packages = [ "libdrm" ]
}

config("fontconfig") {
  libs = [ "fontconfig" ]
}

pkg_config("freetype2") {
  packages = [ "freetype2" ]
}

pkg_config("glib") {
  packages = [ "glib-2.0", "gmodule-2.0", "gobject-2.0", "gthread-2.0" ]
}

pkg_config("gtk") {
  # Gtk requires gmodule, but it does not list it as a dependency in some
  # misconfigured systems.
  packages = [ "gmodule-2.0", "gtk+-2.0", "gthread-2.0" ]
}

pkg_config("pangocairo") {
  packages = [ "pangocairo" ]
}

pkg_config("udev") {
  packages = [ "libudev" ]
}

# Note: if your target also depends on //dbus, you don't need to add this
# config (it will get added automatically if you depend on //dbus).
pkg_config("dbus") {
  packages = [ "dbus-1" ]
}

if (use_evdev_gestures) {
  pkg_config("libevdev-cros") {
    packages = [ "libevdev-cros" ]
  }

  pkg_config("libgestures") {
    packages = [ "libgestures" ]
  }
}

config("x11") {
  # Don't bother running pkg-config for these X related libraries since it just
  # returns the same libs, and forking pkg-config is slow.
  libs = [
    "X11",
    "Xcomposite",
    "Xcursor",
    "Xdamage",
    "Xext",
    "Xfixes",
    "Xi",
    "Xrender",
    "Xss",
    "Xtst",
  ]
}

config("xcomposite") {
  libs = [ "Xcomposite" ]
}

config("xext") {
  libs = [ "Xext" ]
}

config("xrandr") {
  libs = [ "xrandr" ]
}

config("libcap") {
  libs = [ "cap" ]
}

config("libresolv") {
  libs = [ "resolv" ]
}

pkg_config("gconf") {
  packages = [ "gconf-2.0" ]
  defines = [ "USE_GCONF" ]
}

# name: Name to use for the value of the --name arg.
# output_h/output_cc: Names for the generated header/cc file with no dir.
# header: header file to process. Example: "<foo/bar.h>"
# functions: List of strings for functions to process.
# config: Label of the config generated by pkgconfig.
template("generate_library_loader") {
  output_h = "$root_gen_dir/library_loaders/" + invoker.output_h
  output_cc = "$root_gen_dir/library_loaders/" + invoker.output_cc

  action_visibility = ":$target_name"
  action("${target_name}_loader") {
    visibility = action_visibility

    script = "//tools/generate_library_loader/generate_library_loader.py"
    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }

    outputs = [ output_h, output_cc ]

    args = [
      "--name", invoker.name,
      "--output-h", rebase_path(output_h),
      "--output-cc", rebase_path(output_cc),
      "--header", invoker.header,
      # Note GYP build exposes a per-target variable to control this, which, if
      # manually set to true, will disable dlopen(). Its not clear this is
      # needed, so here we just leave off. If this can be done globally, we
      # can expose one switch for this value, otherwise we need to add a template
      # param for this.
      "--link-directly=0",
    ] + invoker.functions
  }

  source_set(target_name) {
    direct_dependent_configs = [ invoker.config ]
    sources = [ output_h, output_cc ]
    deps = [ ":${target_name}_loader" ]
  }
}

pkg_config("gio_config") {
  packages = [ "gio-2.0" ]
  defines = [ "USE_GIO" ]
  ignore_libs = true  # Loader generated below.
}

# This generates a target named "gio".
generate_library_loader("gio") {
  name = "LibGioLoader"
  output_h = "libgio.h"
  output_cc = "libgio_loader.cc"
  header = "<gio/gio.h>"
  config = ":gio_config"

  functions = [
    "g_settings_new",
    "g_settings_get_child",
    "g_settings_get_string",
    "g_settings_get_boolean",
    "g_settings_get_int",
    "g_settings_get_strv",
    "g_settings_list_schemas",
  ]
}

# pkgconfig doesn't return anything interesting for this other than -lpci
# on suppotred systems, so we hardcode.
config("libpci_config") {
  # This is not needed as long as we're setting link_directly=0 for the library
  # loaders.
  #libs = [ "pci" ]
}

# This generates a target named "libpci".
generate_library_loader("libpci") {
  name = "LibPciLoader"
  output_h = "libpci.h"
  output_cc = "libpci_loader.cc"
  header = "<pci/pci.h>"
  config = ":libpci_config"

  functions = [
    "pci_alloc",
    "pci_init",
    "pci_cleanup",
    "pci_scan_bus",
    "pci_fill_info",
    "pci_lookup_name",
  ]
}
