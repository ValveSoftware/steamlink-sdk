<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>D-Bus Tutorial</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" title="D-Bus Tutorial"><div class="titlepage"><div><div><h2 class="title"><a name="index"></a>D-Bus Tutorial</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Havoc</span> <span class="surname">Pennington</span></h3><div class="affiliation"><span class="orgname">Red Hat, Inc.<br></span><div class="address"><p><code class="email">&lt;<a class="email" href="mailto:hp@pobox.com">hp@pobox.com</a>&gt;</code></p></div></div></div><div class="author"><h3 class="author"><span class="firstname">David</span> <span class="surname">Wheeler</span></h3></div><div class="author"><h3 class="author"><span class="firstname">John</span> <span class="surname">Palmieri</span></h3><div class="affiliation"><span class="orgname">Red Hat, Inc.<br></span><div class="address"><p><code class="email">&lt;<a class="email" href="mailto:johnp@redhat.com">johnp@redhat.com</a>&gt;</code></p></div></div></div><div class="author"><h3 class="author"><span class="firstname">Colin</span> <span class="surname">Walters</span></h3><div class="affiliation"><span class="orgname">Red Hat, Inc.<br></span><div class="address"><p><code class="email">&lt;<a class="email" href="mailto:walters@redhat.com">walters@redhat.com</a>&gt;</code></p></div></div></div></div></div><div><p class="releaseinfo">Version 0.5.0</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#meta">Tutorial Work In Progress</a></span></dt><dt><span class="sect1"><a href="#whatis">What is D-Bus?</a></span></dt><dd><dl><dt><span class="sect2"><a href="#uses">D-Bus applications</a></span></dt></dl></dd><dt><span class="sect1"><a href="#concepts">Concepts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#objects">Native Objects and Object Paths</a></span></dt><dt><span class="sect2"><a href="#members">Methods and Signals</a></span></dt><dt><span class="sect2"><a href="#interfaces">Interfaces</a></span></dt><dt><span class="sect2"><a href="#proxies">Proxies</a></span></dt><dt><span class="sect2"><a href="#bus-names">Bus Names</a></span></dt><dt><span class="sect2"><a href="#addresses">Addresses</a></span></dt><dt><span class="sect2"><a href="#bigpicture">Big Conceptual Picture</a></span></dt><dt><span class="sect2"><a href="#messages">Messages - Behind the Scenes</a></span></dt><dt><span class="sect2"><a href="#callprocedure">Calling a Method - Behind the Scenes</a></span></dt><dt><span class="sect2"><a href="#signalprocedure">Emitting a Signal - Behind the Scenes</a></span></dt><dt><span class="sect2"><a href="#introspection">Introspection</a></span></dt></dl></dd><dt><span class="sect1"><a href="#glib-client">GLib API: Using Remote Objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#glib-typemappings">D-Bus - GLib type mappings</a></span></dt><dt><span class="sect2"><a href="#sample-program-1">A sample program</a></span></dt><dt><span class="sect2"><a href="#glib-program-setup">Program initalization</a></span></dt><dt><span class="sect2"><a href="#glib-method-invocation">Understanding method invocation</a></span></dt><dt><span class="sect2"><a href="#glib-signal-connection">Connecting to object signals</a></span></dt><dt><span class="sect2"><a href="#glib-error-handling">Error handling and remote exceptions</a></span></dt><dt><span class="sect2"><a href="#glib-more-examples">More examples of method invocation</a></span></dt><dt><span class="sect2"><a href="#glib-generated-bindings">Generated Bindings</a></span></dt></dl></dd><dt><span class="sect1"><a href="#glib-server">GLib API: Implementing Objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#glib-annotations">Server-side Annotations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#python-client">Python API</a></span></dt><dt><span class="sect1"><a href="#qt-client">Qt API: Using Remote Objects</a></span></dt><dt><span class="sect1"><a href="#qt-server">Qt API: Implementing Objects</a></span></dt></dl></div><div class="sect1" title="Tutorial Work In Progress"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="meta"></a>Tutorial Work In Progress</h2></div></div></div><p>
      This tutorial is not complete; it probably contains some useful information, but 
      also has plenty of gaps. Right now, you'll also need to refer to the D-Bus specification,
      Doxygen reference documentation, and look at some examples of how other apps use D-Bus.
    </p><p>
      Enhancing the tutorial is definitely encouraged - send your patches or suggestions to the
      mailing list. If you create a D-Bus binding, please add a section to the tutorial for your 
      binding, if only a short section with a couple of examples.
    </p></div><div class="sect1" title="What is D-Bus?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whatis"></a>What is D-Bus?</h2></div></div></div><p>
      D-Bus is a system for <em class="firstterm">interprocess communication</em>
      (IPC). Architecturally, it has several layers:

      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
            A library, <em class="firstterm">libdbus</em>, that allows two
            applications to connect to each other and exchange messages.
          </p></li><li class="listitem"><p>
            A <em class="firstterm">message bus daemon</em> executable, built on
            libdbus, that multiple applications can connect to. The daemon can
            route messages from one application to zero or more other
            applications.
          </p></li><li class="listitem"><p>
            <em class="firstterm">Wrapper libraries</em> or <em class="firstterm">bindings</em> 
            based on particular application frameworks.  For example, libdbus-glib and
            libdbus-qt. There are also bindings to languages such as
            Python. These wrapper libraries are the API most people should use,
            as they simplify the details of D-Bus programming. libdbus is 
            intended to be a low-level backend for the higher level bindings.
            Much of the libdbus API is only useful for binding implementation.
          </p></li></ul></div><p>
    </p><p>
      libdbus only supports one-to-one connections, just like a raw network
      socket. However, rather than sending byte streams over the connection, you
      send <em class="firstterm">messages</em>. Messages have a header identifying
      the kind of message, and a body containing a data payload. libdbus also
      abstracts the exact transport used (sockets vs. whatever else), and
      handles details such as authentication.
    </p><p>
      The message bus daemon forms the hub of a wheel. Each spoke of the wheel
      is a one-to-one connection to an application using libdbus.  An
      application sends a message to the bus daemon over its spoke, and the bus
      daemon forwards the message to other connected applications as
      appropriate. Think of the daemon as a router.
    </p><p>
      The bus daemon has multiple instances on a typical computer.  The
      first instance is a machine-global singleton, that is, a system daemon
      similar to sendmail or Apache. This instance has heavy security
      restrictions on what messages it will accept, and is used for systemwide
      communication. The other instances are created one per user login session.
      These instances allow applications in the user's session to communicate 
      with one another.
    </p><p>
      The systemwide and per-user daemons are separate.  Normal within-session
      IPC does not involve the systemwide message bus process and vice versa.
    </p><div class="sect2" title="D-Bus applications"><div class="titlepage"><div><div><h3 class="title"><a name="uses"></a>D-Bus applications</h3></div></div></div><p>
        There are many, many technologies in the world that have "Inter-process
        communication" or "networking" in their stated purpose: <a class="ulink" href="http://www.omg.org" target="_top">CORBA</a>, <a class="ulink" href="http://www.opengroup.org/dce/" target="_top">DCE</a>, <a class="ulink" href="http://www.microsoft.com/com/" target="_top">DCOM</a>, <a class="ulink" href="http://developer.kde.org/documentation/library/kdeqt/dcop.html" target="_top">DCOP</a>, <a class="ulink" href="http://www.xmlrpc.com" target="_top">XML-RPC</a>, <a class="ulink" href="http://www.w3.org/TR/SOAP/" target="_top">SOAP</a>, <a class="ulink" href="http://www.mbus.org/" target="_top">MBUS</a>, <a class="ulink" href="http://www.zeroc.com/ice.html" target="_top">Internet Communications Engine (ICE)</a>,
        and probably hundreds more.
        Each of these is tailored for particular kinds of application.
        D-Bus is designed for two specific cases:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
              Communication between desktop applications in the same desktop
              session; to allow integration of the desktop session as a whole,
              and address issues of process lifecycle (when do desktop components 
              start and stop running).
            </p></li><li class="listitem"><p>
              Communication between the desktop session and the operating system, 
              where the operating system would typically include the kernel 
              and any system daemons or processes.
            </p></li></ul></div><p>
      </p><p>
        For the within-desktop-session use case, the GNOME and KDE desktops 
        have significant previous experience with different IPC solutions
        such as CORBA and DCOP. D-Bus is built on that experience and 
        carefully tailored to meet the needs of these desktop projects 
        in particular. D-Bus may or may not be appropriate for other 
        applications; the FAQ has some comparisons to other IPC systems.
      </p><p>
        The problem solved by the systemwide or communication-with-the-OS case 
        is explained well by the following text from the Linux Hotplug project:
        </p><div class="blockquote"><blockquote class="blockquote"><p>
           A gap in current Linux support is that policies with any sort of
           dynamic "interact with user" component aren't currently
           supported. For example, that's often needed the first time a network
           adapter or printer is connected, and to determine appropriate places
           to mount disk drives. It would seem that such actions could be
           supported for any case where a responsible human can be identified:
           single user workstations, or any system which is remotely
           administered.
          </p><p>
            This is a classic "remote sysadmin" problem, where in this case
            hotplugging needs to deliver an event from one security domain
            (operating system kernel, in this case) to another (desktop for
            logged-in user, or remote sysadmin). Any effective response must go
            the other way: the remote domain taking some action that lets the
            kernel expose the desired device capabilities. (The action can often
            be taken asynchronously, for example letting new hardware be idle
            until a meeting finishes.) At this writing, Linux doesn't have
            widely adopted solutions to such problems. However, the new D-Bus
            work may begin to solve that problem.
          </p></blockquote></div><p>
      </p><p>
        D-Bus may happen to be useful for purposes other than the one it was
        designed for. Its general properties that distinguish it from 
        other forms of IPC are:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
              Binary protocol designed to be used asynchronously 
              (similar in spirit to the X Window System protocol).
            </p></li><li class="listitem"><p>
              Stateful, reliable connections held open over time.
            </p></li><li class="listitem"><p>
              The message bus is a daemon, not a "swarm" or 
              distributed architecture.
            </p></li><li class="listitem"><p>
              Many implementation and deployment issues are specified rather
              than left ambiguous/configurable/pluggable.
            </p></li><li class="listitem"><p>
              Semantics are similar to the existing DCOP system, allowing 
              KDE to adopt it more easily.
            </p></li><li class="listitem"><p>
              Security features to support the systemwide mode of the 
              message bus.
            </p></li></ul></div><p>
      </p></div></div><div class="sect1" title="Concepts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="concepts"></a>Concepts</h2></div></div></div><p>
      Some basic concepts apply no matter what application framework you're
      using to write a D-Bus application. The exact code you write will be
      different for GLib vs. Qt vs. Python applications, however.
    </p><p>
      Here is a diagram (<a class="ulink" href="diagram.png" target="_top">png</a> <a class="ulink" href="diagram.svg" target="_top">svg</a>) that may help you visualize the concepts
      that follow.
    </p><div class="sect2" title="Native Objects and Object Paths"><div class="titlepage"><div><div><h3 class="title"><a name="objects"></a>Native Objects and Object Paths</h3></div></div></div><p>
        Your programming framework probably defines what an "object" is like;
        usually with a base class. For example: java.lang.Object, GObject, QObject,
        python's base Object, or whatever. Let's call this a <em class="firstterm">native object</em>.
      </p><p>
        The low-level D-Bus protocol, and corresponding libdbus API, does not care about native objects. 
        However, it provides a concept called an 
        <em class="firstterm">object path</em>. The idea of an object path is that 
        higher-level bindings can name native object instances, and allow remote applications 
        to refer to them.
      </p><p>
        The object path
        looks like a filesystem path, for example an object could be 
        named <code class="literal">/org/kde/kspread/sheets/3/cells/4/5</code>. 
        Human-readable paths are nice, but you are free to create an 
        object named <code class="literal">/com/mycompany/c5yo817y0c1y1c5b</code> 
        if it makes sense for your application.
      </p><p>
        Namespacing object paths is smart, by starting them with the components
        of a domain name you own (e.g. <code class="literal">/org/kde</code>). This 
        keeps different code modules in the same process from stepping 
        on one another's toes.
      </p></div><div class="sect2" title="Methods and Signals"><div class="titlepage"><div><div><h3 class="title"><a name="members"></a>Methods and Signals</h3></div></div></div><p>
        Each object has <em class="firstterm">members</em>; the two kinds of member
        are <em class="firstterm">methods</em> and
        <em class="firstterm">signals</em>. Methods are operations that can be
        invoked on an object, with optional input (aka arguments or "in
        parameters") and output (aka return values or "out parameters").
        Signals are broadcasts from the object to any interested observers 
        of the object; signals may contain a data payload.
      </p><p>
        Both methods and signals are referred to by name, such as 
        "Frobate" or "OnClicked".
      </p></div><div class="sect2" title="Interfaces"><div class="titlepage"><div><div><h3 class="title"><a name="interfaces"></a>Interfaces</h3></div></div></div><p>
        Each object supports one or more <em class="firstterm">interfaces</em>.
        Think of an interface as a named group of methods and signals, 
        just as it is in GLib or Qt or Java. Interfaces define the 
        <span class="emphasis"><em>type</em></span> of an object instance.
      </p><p>
        DBus identifies interfaces with a simple namespaced string,
        something like <code class="literal">org.freedesktop.Introspectable</code>.
        Most bindings will map these interface names directly to 
        the appropriate programming language construct, for example 
        to Java interfaces or C++ pure virtual classes.
      </p></div><div class="sect2" title="Proxies"><div class="titlepage"><div><div><h3 class="title"><a name="proxies"></a>Proxies</h3></div></div></div><p>
        A <em class="firstterm">proxy object</em> is a convenient native object created to 
        represent a remote object in another process. The low-level DBus API involves manually creating 
        a method call message, sending it, then manually receiving and processing 
        the method reply message. Higher-level bindings provide proxies as an alternative.
        Proxies look like a normal native object; but when you invoke a method on the proxy 
        object, the binding converts it into a DBus method call message, waits for the reply 
        message, unpacks the return value, and returns it from the native method..
      </p><p>
        In pseudocode, programming without proxies might look like this:
        </p><pre class="programlisting">
          Message message = new Message("/remote/object/path", "MethodName", arg1, arg2);
          Connection connection = getBusConnection();
          connection.send(message);
          Message reply = connection.waitForReply(message);
          if (reply.isError()) {
             
          } else {
             Object returnValue = reply.getReturnValue();
          }
        </pre><p>
      </p><p>
        Programming with proxies might look like this:
        </p><pre class="programlisting">
          Proxy proxy = new Proxy(getBusConnection(), "/remote/object/path");
          Object returnValue = proxy.MethodName(arg1, arg2);
        </pre><p>
      </p></div><div class="sect2" title="Bus Names"><div class="titlepage"><div><div><h3 class="title"><a name="bus-names"></a>Bus Names</h3></div></div></div><p>
        When each application connects to the bus daemon, the daemon immediately
        assigns it a name, called the <em class="firstterm">unique connection name</em>.
        A unique name begins with a ':' (colon) character. These names are never 
        reused during the lifetime of the bus daemon - that is, you know 
        a given name will always refer to the same application.
        An example of a unique name might be
        <code class="literal">:34-907</code>. The numbers after the colon have 
        no meaning other than their uniqueness.
      </p><p>
        When a name is mapped 
        to a particular application's connection, that application is said to 
        <em class="firstterm">own</em> that name.
      </p><p>
        Applications may ask to own additional <em class="firstterm">well-known
        names</em>. For example, you could write a specification to
        define a name called <code class="literal">com.mycompany.TextEditor</code>.
        Your definition could specify that to own this name, an application
        should have an object at the path
        <code class="literal">/com/mycompany/TextFileManager</code> supporting the
        interface <code class="literal">org.freedesktop.FileHandler</code>.
      </p><p>
        Applications could then send messages to this bus name, 
        object, and interface to execute method calls.
      </p><p>
        You could think of the unique names as IP addresses, and the
        well-known names as domain names. So
        <code class="literal">com.mycompany.TextEditor</code> might map to something like
        <code class="literal">:34-907</code> just as <code class="literal">mycompany.com</code> maps
        to something like <code class="literal">192.168.0.5</code>.
      </p><p>
        Names have a second important use, other than routing messages.  They
        are used to track lifecycle. When an application exits (or crashes), its
        connection to the message bus will be closed by the operating system
        kernel. The message bus then sends out notification messages telling
        remaining applications that the application's names have lost their
        owner. By tracking these notifications, your application can reliably
        monitor the lifetime of other applications.
      </p><p>
        Bus names can also be used to coordinate single-instance applications.
        If you want to be sure only one
        <code class="literal">com.mycompany.TextEditor</code> application is running for
        example, have the text editor application exit if the bus name already
        has an owner.
      </p></div><div class="sect2" title="Addresses"><div class="titlepage"><div><div><h3 class="title"><a name="addresses"></a>Addresses</h3></div></div></div><p>
        Applications using D-Bus are either servers or clients.  A server
        listens for incoming connections; a client connects to a server. Once
        the connection is established, it is a symmetric flow of messages; the
        client-server distinction only matters when setting up the 
        connection.
      </p><p>
        If you're using the bus daemon, as you probably are, your application 
        will be a client of the bus daemon. That is, the bus daemon listens 
        for connections and your application initiates a connection to the bus 
        daemon.
      </p><p>
        A D-Bus <em class="firstterm">address</em> specifies where a server will
        listen, and where a client will connect.  For example, the address
        <code class="literal">unix:path=/tmp/abcdef</code> specifies that the server will
        listen on a UNIX domain socket at the path
        <code class="literal">/tmp/abcdef</code> and the client will connect to that
        socket. An address can also specify TCP/IP sockets, or any other
        transport defined in future iterations of the D-Bus specification.
      </p><p>
        When using D-Bus with a message bus daemon,
        libdbus automatically discovers the address of the per-session bus 
        daemon by reading an environment variable. It discovers the 
        systemwide bus daemon by checking a well-known UNIX domain socket path
        (though you can override this address with an environment variable).
      </p><p>
        If you're using D-Bus without a bus daemon, it's up to you to 
        define which application will be the server and which will be 
        the client, and specify a mechanism for them to agree on 
        the server's address. This is an unusual case.
      </p></div><div class="sect2" title="Big Conceptual Picture"><div class="titlepage"><div><div><h3 class="title"><a name="bigpicture"></a>Big Conceptual Picture</h3></div></div></div><p>
        Pulling all these concepts together, to specify a particular 
        method call on a particular object instance, a number of 
        nested components have to be named:
        </p><pre class="programlisting">
          Address -&gt; [Bus Name] -&gt; Path -&gt; Interface -&gt; Method
        </pre><p>
        The bus name is in brackets to indicate that it's optional -- you only
        provide a name to route the method call to the right application
        when using the bus daemon. If you have a direct connection to another
        application, bus names aren't used; there's no bus daemon.
      </p><p>
        The interface is also optional, primarily for historical 
        reasons; DCOP does not require specifying the interface, 
        instead simply forbidding duplicate method names 
        on the same object instance. D-Bus will thus let you 
        omit the interface, but if your method name is ambiguous 
        it is undefined which method will be invoked.
      </p></div><div class="sect2" title="Messages - Behind the Scenes"><div class="titlepage"><div><div><h3 class="title"><a name="messages"></a>Messages - Behind the Scenes</h3></div></div></div><p>
        D-Bus works by sending messages between processes. If you're using 
        a sufficiently high-level binding, you may never work with messages directly.
      </p><p>
        There are 4 message types:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
              Method call messages ask to invoke a method 
              on an object.
            </p></li><li class="listitem"><p>
              Method return messages return the results 
              of invoking a method.
            </p></li><li class="listitem"><p>
              Error messages return an exception caused by 
              invoking a method.
            </p></li><li class="listitem"><p>
              Signal messages are notifications that a given signal 
              has been emitted (that an event has occurred). 
              You could also think of these as "event" messages.
            </p></li></ul></div><p>
      </p><p>
        A method call maps very simply to messages: you send a method call
        message, and receive either a method return message or an error message
        in reply.
      </p><p>
        Each message has a <em class="firstterm">header</em>, including <em class="firstterm">fields</em>, 
        and a <em class="firstterm">body</em>, including <em class="firstterm">arguments</em>. You can think 
        of the header as the routing information for the message, and the body as the payload.
        Header fields might include the sender bus name, destination bus name, method or signal name, 
        and so forth. One of the header fields is a <em class="firstterm">type signature</em> describing the 
        values found in the body. For example, the letter "i" means "32-bit integer" so the signature 
        "ii" means the payload has two 32-bit integers.
      </p></div><div class="sect2" title="Calling a Method - Behind the Scenes"><div class="titlepage"><div><div><h3 class="title"><a name="callprocedure"></a>Calling a Method - Behind the Scenes</h3></div></div></div><p>
        A method call in DBus consists of two messages; a method call message sent from process A to process B, 
        and a matching method reply message sent from process B to process A. Both the call and the reply messages
        are routed through the bus daemon. The caller includes a different serial number in each call message, and the
        reply message includes this number to allow the caller to match replies to calls.
      </p><p>
        The call message will contain any arguments to the method.
        The reply message may indicate an error, or may contain data returned by the method.
      </p><p>
        A method invocation in DBus happens as follows:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
              The language binding may provide a proxy, such that invoking a method on 
              an in-process object invokes a method on a remote object in another process. If so, the 
              application calls a method on the proxy, and the proxy
              constructs a method call message to send to the remote process.
            </p></li><li class="listitem"><p>
              For more low-level APIs, the application may construct a method call message itself, without
              using a proxy.
            </p></li><li class="listitem"><p>
              In either case, the method call message contains: a bus name belonging to the remote process; the name of the method; 
              the arguments to the method; an object path inside the remote process; and optionally the name of the 
              interface that specifies the method.
            </p></li><li class="listitem"><p>
              The method call message is sent to the bus daemon.
            </p></li><li class="listitem"><p>
              The bus daemon looks at the destination bus name. If a process owns that name, 
              the bus daemon forwards the method call to that process. Otherwise, the bus daemon
              creates an error message and sends it back as the reply to the method call message.
            </p></li><li class="listitem"><p>
              The receiving process unpacks the method call message. In a simple low-level API situation, it 
              may immediately run the method and send a method reply message to the bus daemon.
              When using a high-level binding API, the binding might examine the object path, interface,
              and method name, and convert the method call message into an invocation of a method on 
              a native object (GObject, java.lang.Object, QObject, etc.), then convert the return 
              value from the native method into a method reply message.
            </p></li><li class="listitem"><p>
              The bus daemon receives the method reply message and sends it to the process that 
              made the method call.
            </p></li><li class="listitem"><p>
              The process that made the method call looks at the method reply and makes use of any 
              return values included in the reply. The reply may also indicate that an error occurred.
              When using a binding, the method reply message may be converted into the return value of 
              of a proxy method, or into an exception.
            </p></li></ul></div><p>
      </p><p>
        The bus daemon never reorders messages. That is, if you send two method call messages to the same recipient, 
        they will be received in the order they were sent. The recipient is not required to reply to the calls
        in order, however; for example, it may process each method call in a separate thread, and return reply messages
        in an undefined order depending on when the threads complete. Method calls have a unique serial 
        number used by the method caller to match reply messages to call messages.
      </p></div><div class="sect2" title="Emitting a Signal - Behind the Scenes"><div class="titlepage"><div><div><h3 class="title"><a name="signalprocedure"></a>Emitting a Signal - Behind the Scenes</h3></div></div></div><p>
        A signal in DBus consists of a single message, sent by one process to any number of other processes. 
        That is, a signal is a unidirectional broadcast. The signal may contain arguments (a data payload), but 
        because it is a broadcast, it never has a "return value." Contrast this with a method call 
        (see <a class="xref" href="#callprocedure" title="Calling a Method - Behind the Scenes">the section called &#8220;Calling a Method - Behind the Scenes&#8221;</a>) where the method call message has a matching method reply message.
      </p><p>
        The emitter (aka sender) of a signal has no knowledge of the signal recipients. Recipients register
        with the bus daemon to receive signals based on "match rules" - these rules would typically include the sender and 
        the signal name. The bus daemon sends each signal only to recipients who have expressed interest in that 
        signal.
      </p><p>
        A signal in DBus happens as follows:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
              A signal message is created and sent to the bus daemon. When using the low-level API this may be 
              done manually, with certain bindings it may be done for you by the binding when a native object
              emits a native signal or event.
            </p></li><li class="listitem"><p>
              The signal message contains the name of the interface that specifies the signal;
              the name of the signal; the bus name of the process sending the signal; and 
              any arguments 
            </p></li><li class="listitem"><p>
              Any process on the message bus can register "match rules" indicating which signals it 
              is interested in. The bus has a list of registered match rules.
            </p></li><li class="listitem"><p>
              The bus daemon examines the signal and determines which processes are interested in it.
              It sends the signal message to these processes.
            </p></li><li class="listitem"><p>
              Each process receiving the signal decides what to do with it; if using a binding, 
              the binding may choose to emit a native signal on a proxy object. If using the 
              low-level API, the process may just look at the signal sender and name and decide
              what to do based on that.
            </p></li></ul></div><p>
      </p></div><div class="sect2" title="Introspection"><div class="titlepage"><div><div><h3 class="title"><a name="introspection"></a>Introspection</h3></div></div></div><p>
        D-Bus objects may support the interface <code class="literal">org.freedesktop.DBus.Introspectable</code>.
        This interface has one method <code class="literal">Introspect</code> which takes no arguments and returns
        an XML string. The XML string describes the interfaces, methods, and signals of the object.
        See the D-Bus specification for more details on this introspection format.
      </p></div></div><div class="sect1" title="GLib API: Using Remote Objects"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="glib-client"></a>GLib API: Using Remote Objects</h2></div></div></div><p>
      The GLib binding is defined in the header file
      <code class="literal">&lt;dbus/dbus-glib.h&gt;</code>.
    </p><div class="sect2" title="D-Bus - GLib type mappings"><div class="titlepage"><div><div><h3 class="title"><a name="glib-typemappings"></a>D-Bus - GLib type mappings</h3></div></div></div><p>
	The heart of the GLib bindings for D-Bus is the mapping it
	provides between D-Bus "type signatures" and GLib types
	(<code class="literal">GType</code>). The D-Bus type system is composed of
	a number of "basic" types, along with several "container" types.
      </p><div class="sect3" title="Basic type mappings"><div class="titlepage"><div><div><h4 class="title"><a name="glib-basic-typemappings"></a>Basic type mappings</h4></div></div></div><p>
	  Below is a list of the basic types, along with their associated
	  mapping to a <code class="literal">GType</code>.
	  </p><div class="informaltable"><table border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>D-Bus basic type</th><th>GType</th><th>Free function</th><th>Notes</th></tr></thead><tbody><tr><td><code class="literal">BYTE</code></td><td><code class="literal">G_TYPE_UCHAR</code></td><td> </td><td> </td></tr><tr><td><code class="literal">BOOLEAN</code></td><td><code class="literal">G_TYPE_BOOLEAN</code></td><td> </td><td> </td></tr><tr><td><code class="literal">INT16</code></td><td><code class="literal">G_TYPE_INT</code></td><td> </td><td>Will be changed to a <code class="literal">G_TYPE_INT16</code> once GLib has it</td></tr><tr><td><code class="literal">UINT16</code></td><td><code class="literal">G_TYPE_UINT</code></td><td> </td><td>Will be changed to a <code class="literal">G_TYPE_UINT16</code> once GLib has it</td></tr><tr><td><code class="literal">INT32</code></td><td><code class="literal">G_TYPE_INT</code></td><td> </td><td>Will be changed to a <code class="literal">G_TYPE_INT32</code> once GLib has it</td></tr><tr><td><code class="literal">UINT32</code></td><td><code class="literal">G_TYPE_UINT</code></td><td> </td><td>Will be changed to a <code class="literal">G_TYPE_UINT32</code> once GLib has it</td></tr><tr><td><code class="literal">INT64</code></td><td><code class="literal">G_TYPE_GINT64</code></td><td> </td><td> </td></tr><tr><td><code class="literal">UINT64</code></td><td><code class="literal">G_TYPE_GUINT64</code></td><td> </td><td> </td></tr><tr><td><code class="literal">DOUBLE</code></td><td><code class="literal">G_TYPE_DOUBLE</code></td><td> </td><td> </td></tr><tr><td><code class="literal">STRING</code></td><td><code class="literal">G_TYPE_STRING</code></td><td><code class="literal">g_free</code></td><td> </td></tr><tr><td><code class="literal">OBJECT_PATH</code></td><td><code class="literal">DBUS_TYPE_G_PROXY</code></td><td><code class="literal">g_object_unref</code></td><td>The returned proxy does not have an interface set; use <code class="literal">dbus_g_proxy_set_interface</code> to invoke methods</td></tr></tbody></table></div><p>
	  As you can see, the basic mapping is fairly straightforward.
	</p></div><div class="sect3" title="Container type mappings"><div class="titlepage"><div><div><h4 class="title"><a name="glib-container-typemappings"></a>Container type mappings</h4></div></div></div><p>
	  The D-Bus type system also has a number of "container"
	  types, such as <code class="literal">DBUS_TYPE_ARRAY</code> and
	  <code class="literal">DBUS_TYPE_STRUCT</code>.  The D-Bus type system
	  is fully recursive, so one can for example have an array of
	  array of strings (i.e. type signature
	  <code class="literal">aas</code>).
	</p><p>
	  However, not all of these types are in common use; for
	  example, at the time of this writing the author knows of no
	  one using <code class="literal">DBUS_TYPE_STRUCT</code>, or a
	  <code class="literal">DBUS_TYPE_ARRAY</code> containing any non-basic
	  type.  The approach the GLib bindings take is pragmatic; try
	  to map the most common types in the most obvious way, and
	  let using less common and more complex types be less
	  "natural".
	</p><p>
	  First, D-Bus type signatures which have an "obvious"
	  corresponding built-in GLib type are mapped using that type:
	  </p><div class="informaltable"><table border="1"><colgroup><col><col><col><col><col><col></colgroup><thead><tr><th>D-Bus type signature</th><th>Description</th><th>GType</th><th>C typedef</th><th>Free function</th><th>Notes</th></tr></thead><tbody><tr><td><code class="literal">as</code></td><td>Array of strings</td><td><code class="literal">G_TYPE_STRV</code></td><td><code class="literal">char **</code></td><td><code class="literal">g_strfreev</code></td><td> </td></tr><tr><td><code class="literal">v</code></td><td>Generic value container</td><td><code class="literal">G_TYPE_VALUE</code></td><td><code class="literal">GValue *</code></td><td><code class="literal">g_value_unset</code></td><td>The calling conventions for values expect that method callers have allocated return values; see below.</td></tr></tbody></table></div><p>
	</p><p>
	  The next most common recursive type signatures are arrays of
	  basic values.  The most obvious mapping for arrays of basic
	  types is a <code class="literal">GArray</code>.  Now, GLib does not
	  provide a builtin <code class="literal">GType</code> for
	  <code class="literal">GArray</code>.  However, we actually need more than
	  that - we need a "parameterized" type which includes the
	  contained type.  Why we need this we will see below.
	</p><p>
	  The approach taken is to create these types in the D-Bus GLib
	  bindings; however, there is nothing D-Bus specific about them.
	  In the future, we hope to include such "fundamental" types in GLib
	  itself.
	  </p><div class="informaltable"><table border="1"><colgroup><col><col><col><col><col><col></colgroup><thead><tr><th>D-Bus type signature</th><th>Description</th><th>GType</th><th>C typedef</th><th>Free function</th><th>Notes</th></tr></thead><tbody><tr><td><code class="literal">ay</code></td><td>Array of bytes</td><td><code class="literal">DBUS_TYPE_G_BYTE_ARRAY</code></td><td><code class="literal">GArray *</code></td><td>g_array_free</td><td> </td></tr><tr><td><code class="literal">au</code></td><td>Array of uint</td><td><code class="literal">DBUS_TYPE_G_UINT_ARRAY</code></td><td><code class="literal">GArray *</code></td><td>g_array_free</td><td> </td></tr><tr><td><code class="literal">ai</code></td><td>Array of int</td><td><code class="literal">DBUS_TYPE_G_INT_ARRAY</code></td><td><code class="literal">GArray *</code></td><td>g_array_free</td><td> </td></tr><tr><td><code class="literal">ax</code></td><td>Array of int64</td><td><code class="literal">DBUS_TYPE_G_INT64_ARRAY</code></td><td><code class="literal">GArray *</code></td><td>g_array_free</td><td> </td></tr><tr><td><code class="literal">at</code></td><td>Array of uint64</td><td><code class="literal">DBUS_TYPE_G_UINT64_ARRAY</code></td><td><code class="literal">GArray *</code></td><td>g_array_free</td><td> </td></tr><tr><td><code class="literal">ad</code></td><td>Array of double</td><td><code class="literal">DBUS_TYPE_G_DOUBLE_ARRAY</code></td><td><code class="literal">GArray *</code></td><td>g_array_free</td><td> </td></tr><tr><td><code class="literal">ab</code></td><td>Array of boolean</td><td><code class="literal">DBUS_TYPE_G_BOOLEAN_ARRAY</code></td><td><code class="literal">GArray *</code></td><td>g_array_free</td><td> </td></tr></tbody></table></div><p>
	</p><p>
	  D-Bus also includes a special type DBUS_TYPE_DICT_ENTRY which
	  is only valid in arrays.  It's intended to be mapped to a "dictionary"
	  type by bindings.  The obvious GLib mapping here is GHashTable.  Again,
	  however, there is no builtin <code class="literal">GType</code> for a GHashTable.
	  Moreover, just like for arrays, we need a parameterized type so that
	  the bindings can communiate which types are contained in the hash table.
	</p><p>
	  At present, only strings are supported.  Work is in progress to
	  include more types.
	  </p><div class="informaltable"><table border="1"><colgroup><col><col><col><col><col><col></colgroup><thead><tr><th>D-Bus type signature</th><th>Description</th><th>GType</th><th>C typedef</th><th>Free function</th><th>Notes</th></tr></thead><tbody><tr><td><code class="literal">a{ss}</code></td><td>Dictionary mapping strings to strings</td><td><code class="literal">DBUS_TYPE_G_STRING_STRING_HASHTABLE</code></td><td><code class="literal">GHashTable *</code></td><td>g_hash_table_destroy</td><td> </td></tr></tbody></table></div><p>
	</p></div><div class="sect3" title="Arbitrarily recursive type mappings"><div class="titlepage"><div><div><h4 class="title"><a name="glib-generic-typemappings"></a>Arbitrarily recursive type mappings</h4></div></div></div><p>
	  Finally, it is possible users will want to write or invoke D-Bus
	  methods which have arbitrarily complex type signatures not
	  directly supported by these bindings.  For this case, we have a
	  <code class="literal">DBusGValue</code> which acts as a kind of special
	  variant value which may be iterated over manually.  The
	  <code class="literal">GType</code> associated is
	  <code class="literal">DBUS_TYPE_G_VALUE</code>.
	</p><p>
	  TODO insert usage of <code class="literal">DBUS_TYPE_G_VALUE</code> here.
	</p></div></div><div class="sect2" title="A sample program"><div class="titlepage"><div><div><h3 class="title"><a name="sample-program-1"></a>A sample program</h3></div></div></div><p>Here is a D-Bus program using the GLib bindings.
</p><pre class="programlisting">      
int
main (int argc, char **argv)
{
  DBusGConnection *connection;
  GError *error;
  DBusGProxy *proxy;
  char **name_list;
  char **name_list_ptr;
  
  g_type_init ();

  error = NULL;
  connection = dbus_g_bus_get (DBUS_BUS_SESSION,
                               &amp;error);
  if (connection == NULL)
    {
      g_printerr ("Failed to open connection to bus: %s\n",
                  error-&gt;message);
      g_error_free (error);
      exit (1);
    }

  /* Create a proxy object for the "bus driver" (name "org.freedesktop.DBus") */
  
  proxy = dbus_g_proxy_new_for_name (connection,
                                     DBUS_SERVICE_DBUS,
                                     DBUS_PATH_DBUS,
                                     DBUS_INTERFACE_DBUS);

  /* Call ListNames method, wait for reply */
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "ListNames", &amp;error, G_TYPE_INVALID,
                          G_TYPE_STRV, &amp;name_list, G_TYPE_INVALID))
    {
      /* Just do demonstrate remote exceptions versus regular GError */
      if (error-&gt;domain == DBUS_GERROR &amp;&amp; error-&gt;code == DBUS_GERROR_REMOTE_EXCEPTION)
        g_printerr ("Caught remote method exception %s: %s",
	            dbus_g_error_get_name (error),
	            error-&gt;message);
      else
        g_printerr ("Error: %s\n", error-&gt;message);
      g_error_free (error);
      exit (1);
    }

  /* Print the results */
 
  g_print ("Names on the message bus:\n");
  
  for (name_list_ptr = name_list; *name_list_ptr; name_list_ptr++)
    {
      g_print ("  %s\n", *name_list_ptr);
    }
  g_strfreev (name_list);

  g_object_unref (proxy);

  return 0;
}
</pre><p>
    </p></div><div class="sect2" title="Program initalization"><div class="titlepage"><div><div><h3 class="title"><a name="glib-program-setup"></a>Program initalization</h3></div></div></div><p>
	A connection to the bus is acquired using
	<code class="literal">dbus_g_bus_get</code>.  Next, a proxy
	is created for the object "/org/freedesktop/DBus" with
	interface <code class="literal">org.freedesktop.DBus</code>
	on the service <code class="literal">org.freedesktop.DBus</code>.
	This is a proxy for the message bus itself.
      </p></div><div class="sect2" title="Understanding method invocation"><div class="titlepage"><div><div><h3 class="title"><a name="glib-method-invocation"></a>Understanding method invocation</h3></div></div></div><p>
	You have a number of choices for method invocation.  First, as
	used above, <code class="literal">dbus_g_proxy_call</code> sends a
	method call to the remote object, and blocks until a reply is
	recieved.  The outgoing arguments are specified in the varargs
	array, terminated with <code class="literal">G_TYPE_INVALID</code>.
	Next, pointers to return values are specified, followed again
	by <code class="literal">G_TYPE_INVALID</code>.
      </p><p>
	To invoke a method asynchronously, use
	<code class="literal">dbus_g_proxy_begin_call</code>.  This returns a
	<code class="literal">DBusGPendingCall</code> object; you may then set a
	notification function using
	<code class="literal">dbus_g_pending_call_set_notify</code>.
      </p></div><div class="sect2" title="Connecting to object signals"><div class="titlepage"><div><div><h3 class="title"><a name="glib-signal-connection"></a>Connecting to object signals</h3></div></div></div><p>
	You may connect to signals using
	<code class="literal">dbus_g_proxy_add_signal</code> and
	<code class="literal">dbus_g_proxy_connect_signal</code>.  You must
	invoke <code class="literal">dbus_g_proxy_add_signal</code> to specify
	the signature of your signal handlers; you may then invoke
	<code class="literal">dbus_g_proxy_connect_signal</code> multiple times.
      </p><p>
	Note that it will often be the case that there is no builtin
	marshaller for the type signature of a remote signal.  In that
	case, you must generate a marshaller yourself by using
	<span class="application">glib-genmarshal</span>, and then register
	it using <code class="literal">dbus_g_object_register_marshaller</code>.
      </p></div><div class="sect2" title="Error handling and remote exceptions"><div class="titlepage"><div><div><h3 class="title"><a name="glib-error-handling"></a>Error handling and remote exceptions</h3></div></div></div><p>
	All of the GLib binding methods such as
	<code class="literal">dbus_g_proxy_end_call</code> return a
	<code class="literal">GError</code>.  This <code class="literal">GError</code> can
	represent two different things:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
	    An internal D-Bus error, such as an out-of-memory
	    condition, an I/O error, or a network timeout.  Errors
	    generated by the D-Bus library itself have the domain
	    <code class="literal">DBUS_GERROR</code>, and a corresponding code
	    such as <code class="literal">DBUS_GERROR_NO_MEMORY</code>.  It will
	    not be typical for applications to handle these errors
	    specifically.
	  </p></li><li class="listitem"><p>
	    A remote D-Bus exception, thrown by the peer, bus, or
	    service.  D-Bus remote exceptions have both a textual
	    "name" and a "message".  The GLib bindings store this
	    information in the <code class="literal">GError</code>, but some
	    special rules apply.
	  </p><p>
	    The set error will have the domain
	    <code class="literal">DBUS_GERROR</code> as above, and will also
	    have the code
	    <code class="literal">DBUS_GERROR_REMOTE_EXCEPTION</code>.  In order
	    to access the remote exception name, you must use a
	    special accessor, such as
	    <code class="literal">dbus_g_error_has_name</code> or
	    <code class="literal">dbus_g_error_get_name</code>.  The remote
	    exception detailed message is accessible via the regular
	    GError <code class="literal">message</code> member.
	  </p></li></ul></div><p>
      </p></div><div class="sect2" title="More examples of method invocation"><div class="titlepage"><div><div><h3 class="title"><a name="glib-more-examples"></a>More examples of method invocation</h3></div></div></div><div class="sect3" title="Sending an integer and string, receiving an array of bytes"><div class="titlepage"><div><div><h4 class="title"><a name="glib-sending-stuff"></a>Sending an integer and string, receiving an array of bytes</h4></div></div></div><p>
</p><pre class="programlisting">
  GArray *arr;
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "Foobar", &amp;error,
                          G_TYPE_INT, 42, G_TYPE_STRING, "hello",
			  G_TYPE_INVALID,
			  DBUS_TYPE_G_UCHAR_ARRAY, &amp;arr, G_TYPE_INVALID))
    {
      /* Handle error */
    }
   g_assert (arr != NULL);
   printf ("got back %u values", arr-&gt;len);
</pre><p>
	</p></div><div class="sect3" title="Sending a GHashTable"><div class="titlepage"><div><div><h4 class="title"><a name="glib-sending-hash"></a>Sending a GHashTable</h4></div></div></div><p>
</p><pre class="programlisting">
  GHashTable *hash = g_hash_table_new (g_str_hash, g_str_equal);
  guint32 ret;
  
  g_hash_table_insert (hash, "foo", "bar");
  g_hash_table_insert (hash, "baz", "whee");

  error = NULL;
  if (!dbus_g_proxy_call (proxy, "HashSize", &amp;error,
                          DBUS_TYPE_G_STRING_STRING_HASH, hash, G_TYPE_INVALID,
			  G_TYPE_UINT, &amp;ret, G_TYPE_INVALID))
    {
      /* Handle error */
    }
  g_assert (ret == 2);
  g_hash_table_destroy (hash);
</pre><p>
	</p></div><div class="sect3" title="Receiving a boolean and a string"><div class="titlepage"><div><div><h4 class="title"><a name="glib-receiving-bool-int"></a>Receiving a boolean and a string</h4></div></div></div><p>
</p><pre class="programlisting">
  gboolean boolret;
  char *strret;
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "GetStuff", &amp;error,
			  G_TYPE_INVALID,
                          G_TYPE_BOOLEAN, &amp;boolret,
                          G_TYPE_STRING, &amp;strret,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
  printf ("%s %s", boolret ? "TRUE" : "FALSE", strret);
  g_free (strret);
</pre><p>
	</p></div><div class="sect3" title="Sending two arrays of strings"><div class="titlepage"><div><div><h4 class="title"><a name="glib-sending-str-arrays"></a>Sending two arrays of strings</h4></div></div></div><p>
</p><pre class="programlisting">
  /* NULL terminate */
  char *strs_static[] = {"foo", "bar", "baz", NULL};
  /* Take pointer to array; cannot pass array directly */
  char **strs_static_p = strs_static;
  char **strs_dynamic;

  strs_dynamic = g_new (char *, 4);
  strs_dynamic[0] = g_strdup ("hello");
  strs_dynamic[1] = g_strdup ("world");
  strs_dynamic[2] = g_strdup ("!");
  /* NULL terminate */
  strs_dynamic[3] = NULL;
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "TwoStrArrays", &amp;error,
                          G_TYPE_STRV, strs_static_p,
                          G_TYPE_STRV, strs_dynamic,
			  G_TYPE_INVALID,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
   g_strfreev (strs_dynamic);
</pre><p>
	</p></div><div class="sect3" title="Sending a boolean, receiving an array of strings"><div class="titlepage"><div><div><h4 class="title"><a name="glib-getting-str-array"></a>Sending a boolean, receiving an array of strings</h4></div></div></div><p>
</p><pre class="programlisting">
  char **strs;
  char **strs_p;
  gboolean blah;

  error = NULL;
  blah = TRUE;
  if (!dbus_g_proxy_call (proxy, "GetStrs", &amp;error,
                          G_TYPE_BOOLEAN, blah,
			  G_TYPE_INVALID,
                          G_TYPE_STRV, &amp;strs,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
   for (strs_p = strs; *strs_p; strs_p++)
     printf ("got string: \"%s\"", *strs_p);
   g_strfreev (strs);
</pre><p>
	</p></div><div class="sect3" title="Sending a variant"><div class="titlepage"><div><div><h4 class="title"><a name="glib-sending-variant"></a>Sending a variant</h4></div></div></div><p>
</p><pre class="programlisting">
  GValue val = {0, };

  g_value_init (&amp;val, G_TYPE_STRING);
  g_value_set_string (&amp;val, "hello world");
  
  error = NULL;
  if (!dbus_g_proxy_call (proxy, "SendVariant", &amp;error,
                          G_TYPE_VALUE, &amp;val, G_TYPE_INVALID,
			  G_TYPE_INVALID))
    {
      /* Handle error */
    }
  g_assert (ret == 2);
  g_value_unset (&amp;val);
</pre><p>
	</p></div><div class="sect3" title="Receiving a variant"><div class="titlepage"><div><div><h4 class="title"><a name="glib-receiving-variant"></a>Receiving a variant</h4></div></div></div><p>
</p><pre class="programlisting">
  GValue val = {0, };

  error = NULL;
  if (!dbus_g_proxy_call (proxy, "GetVariant", &amp;error, G_TYPE_INVALID,
                          G_TYPE_VALUE, &amp;val, G_TYPE_INVALID))
    {
      /* Handle error */
    }
  if (G_VALUE_TYPE (&amp;val) == G_TYPE_STRING)
    printf ("%s\n", g_value_get_string (&amp;val));
  else if (G_VALUE_TYPE (&amp;val) == G_TYPE_INT)
    printf ("%d\n", g_value_get_int (&amp;val));
  else
    ...
  g_value_unset (&amp;val);
</pre><p>
	</p></div></div><div class="sect2" title="Generated Bindings"><div class="titlepage"><div><div><h3 class="title"><a name="glib-generated-bindings"></a>Generated Bindings</h3></div></div></div><p>
        By using the Introspection XML files, convenient client-side bindings
        can be automatically created to ease the use of a remote DBus object.
      </p><p>
        Here is a sample XML file which describes an object that exposes
        one method, named <code class="literal">ManyArgs</code>.
        </p><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;node name="/com/example/MyObject"&gt;
  &lt;interface name="com.example.MyObject"&gt;
    &lt;method name="ManyArgs"&gt;
      &lt;arg type="u" name="x" direction="in" /&gt;
      &lt;arg type="s" name="str" direction="in" /&gt;
      &lt;arg type="d" name="trouble" direction="in" /&gt;
      &lt;arg type="d" name="d_ret" direction="out" /&gt;
      &lt;arg type="s" name="str_ret" direction="out" /&gt;
    &lt;/method&gt;
  &lt;/interface&gt;
&lt;/node&gt;
</pre><p>
      </p><p>
        Run <code class="literal">dbus-binding-tool --mode=glib-client
          <em class="replaceable"><code>FILENAME</code></em> &gt;
          <em class="replaceable"><code>HEADER_NAME</code></em></code> to generate the header
        file.  For example: <span class="command"><strong>dbus-binding-tool --mode=glib-client
          my-object.xml &gt; my-object-bindings.h</strong></span>.  This will generate
        inline functions with the following prototypes:
        </p><pre class="programlisting">
/* This is a blocking call */
gboolean
com_example_MyObject_many_args (DBusGProxy *proxy, const guint IN_x,
                                const char * IN_str, const gdouble IN_trouble,
                                gdouble* OUT_d_ret, char ** OUT_str_ret,
                                GError **error);

/* This is a non-blocking call */
DBusGProxyCall*
com_example_MyObject_many_args_async (DBusGProxy *proxy, const guint IN_x,
                                      const char * IN_str, const gdouble IN_trouble,
                                      com_example_MyObject_many_args_reply callback,
                                      gpointer userdata);

/* This is the typedef for the non-blocking callback */
typedef void
(*com_example_MyObject_many_args_reply)
(DBusGProxy *proxy, gdouble OUT_d_ret, char * OUT_str_ret,
 GError *error, gpointer userdata);
</pre><p>
        The first argument in all functions is a <code class="literal">DBusGProxy
        *</code>, which you should create with the usual
        <code class="literal">dbus_g_proxy_new_*</code> functions.  Following that are the
        "in" arguments, and then either the "out" arguments and a
        <code class="literal">GError *</code> for the synchronous (blocking) function, or
        callback and user data arguments for the asynchronous (non-blocking)
        function.  The callback in the asynchronous function passes the
        <code class="literal">DBusGProxy *</code>, the returned "out" arguments, an
        <code class="literal">GError *</code> which is set if there was an error otherwise
        <code class="literal">NULL</code>, and the user data.
      </p><p>
        As with the server-side bindings support (see <a class="xref" href="#glib-server" title="GLib API: Implementing Objects">the section called &#8220;GLib API: Implementing Objects&#8221;</a>), the exact behaviour of the client-side
        bindings can be manipulated using "annotations".  Currently the only
        annotation used by the client bindings is
        <code class="literal">org.freedesktop.DBus.GLib.NoReply</code>, which sets the
        flag indicating that the client isn't expecting a reply to the method
        call, so a reply shouldn't be sent.  This is often used to speed up
        rapid method calls where there are no "out" arguments, and not knowing
        if the method succeeded is an acceptable compromise to half the traffic
        on the bus.
      </p></div></div><div class="sect1" title="GLib API: Implementing Objects"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="glib-server"></a>GLib API: Implementing Objects</h2></div></div></div><p>
      At the moment, to expose a GObject via D-Bus, you must
      write XML by hand which describes the methods exported
      by the object.  In the future, this manual step will
      be obviated by the upcoming GLib introspection support.
    </p><p>
      Here is a sample XML file which describes an object that exposes
      one method, named <code class="literal">ManyArgs</code>.
</p><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;

&lt;node name="/com/example/MyObject"&gt;

  &lt;interface name="com.example.MyObject"&gt;
    &lt;annotation name="org.freedesktop.DBus.GLib.CSymbol" value="my_object"/&gt;
    &lt;method name="ManyArgs"&gt;
      &lt;!-- This is optional, and in this case is redunundant --&gt;
      &lt;annotation name="org.freedesktop.DBus.GLib.CSymbol" value="my_object_many_args"/&gt;
      &lt;arg type="u" name="x" direction="in" /&gt;
      &lt;arg type="s" name="str" direction="in" /&gt;
      &lt;arg type="d" name="trouble" direction="in" /&gt;
      &lt;arg type="d" name="d_ret" direction="out" /&gt;
      &lt;arg type="s" name="str_ret" direction="out" /&gt;
    &lt;/method&gt;
  &lt;/interface&gt;
&lt;/node&gt;
</pre><p>
    </p><p>
      This XML is in the same format as the D-Bus introspection XML
      format. Except we must include an "annotation" which give the C
      symbols corresponding to the object implementation prefix
      (<code class="literal">my_object</code>).  In addition, if particular
      methods symbol names deviate from C convention
      (i.e. <code class="literal">ManyArgs</code> -&gt;
      <code class="literal">many_args</code>), you may specify an annotation
      giving the C symbol.
    </p><p>
      Once you have written this XML, run <code class="literal">dbus-binding-tool --mode=glib-server <em class="replaceable"><code>FILENAME</code></em> &gt; <em class="replaceable"><code>HEADER_NAME</code></em>.</code> to
      generate a header file.  For example: <span class="command"><strong>dbus-binding-tool --mode=glib-server my-object.xml &gt; my-object-glue.h</strong></span>.
    </p><p>
      Next, include the generated header in your program, and invoke
      <code class="literal">dbus_g_object_class_install_info</code> in the class
      initializer, passing the object class and "object info" included in the
      header.  For example:
      </p><pre class="programlisting">
	dbus_g_object_type_install_info (COM_FOO_TYPE_MY_OBJECT, &amp;com_foo_my_object_info);
      </pre><p>
      This should be done exactly once per object class.
    </p><p>
      To actually implement the method, just define a C function named e.g.
      <code class="literal">my_object_many_args</code> in the same file as the info
      header is included.  At the moment, it is required that this function
      conform to the following rules:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
	    The function must return a value of type <code class="literal">gboolean</code>;
	    <code class="literal">TRUE</code> on success, and <code class="literal">FALSE</code>
	    otherwise.
	  </p></li><li class="listitem"><p>
	    The first parameter is a pointer to an instance of the object.
	  </p></li><li class="listitem"><p>
	    Following the object instance pointer are the method
	    input values.
	  </p></li><li class="listitem"><p>
	    Following the input values are pointers to return values.
	  </p></li><li class="listitem"><p>
	    The final parameter must be a <code class="literal">GError **</code>.
	    If the function returns <code class="literal">FALSE</code> for an
	    error, the error parameter must be initalized with
	    <code class="literal">g_set_error</code>.
	  </p></li></ul></div><p>
    </p><p>
      Finally, you can export an object using <code class="literal">dbus_g_connection_register_g_object</code>.  For example:
      </p><pre class="programlisting">
	  dbus_g_connection_register_g_object (connection,
                                               "/com/foo/MyObject",
                                               obj);
      </pre><p>
    </p><div class="sect2" title="Server-side Annotations"><div class="titlepage"><div><div><h3 class="title"><a name="glib-annotations"></a>Server-side Annotations</h3></div></div></div><p>
        There are several annotations that are used when generating the
        server-side bindings.  The most common annotation is
        <code class="literal">org.freedesktop.DBus.GLib.CSymbol</code> but there are other
        annotations which are often useful.
        </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">org.freedesktop.DBus.GLib.CSymbol</code></span></dt><dd><p>
                This annotation is used to specify the C symbol names for
                the various types (interface, method, etc), if it differs from the
                name DBus generates.
              </p></dd><dt><span class="term"><code class="literal">org.freedesktop.DBus.GLib.Async</code></span></dt><dd><p>
                This annotation marks the method implementation as an
                asynchronous function, which doesn't return a response straight
                away but will send the response at some later point to complete
                the call.  This is used to implement non-blocking services where
                method calls can take time.
              </p><p>
                When a method is asynchronous, the function prototype is
                different. It is required that the function conform to the
                following rules:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                      The function must return a value of type <code class="literal">gboolean</code>;
                      <code class="literal">TRUE</code> on success, and <code class="literal">FALSE</code>
                      otherwise. TODO: the return value is currently ignored.
                    </p></li><li class="listitem"><p>
                      The first parameter is a pointer to an instance of the object.
                    </p></li><li class="listitem"><p>
                      Following the object instance pointer are the method
                      input values.
                    </p></li><li class="listitem"><p>
                      The final parameter must be a
                      <code class="literal">DBusGMethodInvocation *</code>.  This is used
                      when sending the response message back to the client, by
                      calling <code class="literal">dbus_g_method_return</code> or
                      <code class="literal">dbus_g_method_return_error</code>.
                    </p></li></ul></div><p>
              </p></dd><dt><span class="term"><code class="literal">org.freedesktop.DBus.GLib.Const</code></span></dt><dd><p>This attribute can only be applied to "out"
              <code class="literal">&lt;arg&gt;</code> nodes, and specifies that the
              parameter isn't being copied when returned.  For example, this
              turns a 's' argument from a <code class="literal">char **</code> to a
              <code class="literal">const char **</code>, and results in the argument not
              being freed by DBus after the message is sent.
              </p></dd><dt><span class="term"><code class="literal">org.freedesktop.DBus.GLib.ReturnVal</code></span></dt><dd><p>
                This attribute can only be applied to "out"
                <code class="literal">&lt;arg&gt;</code> nodes, and alters the expected
                function signature.  It currently can be set to two values:
                <code class="literal">""</code> or <code class="literal">"error"</code>.  The
                argument marked with this attribute is not returned via a
                pointer argument, but by the function's return value.  If the
                attribute's value is the empty string, the <code class="literal">GError
                *</code> argument is also omitted so there is no standard way
                to return an error value.  This is very useful for interfacing
                with existing code, as it is possible to match existing APIs.
                If the attribute's value is <code class="literal">"error"</code>, then the
                final argument is a <code class="literal">GError *</code> as usual.
              </p><p>
                Some examples to demonstrate the usage. This introspection XML:
                </p><pre class="programlisting">
&lt;method name="Increment"&gt;
  &lt;arg type="u" name="x" /&gt;
  &lt;arg type="u" direction="out" /&gt;
&lt;/method&gt;
                </pre><p>
                Expects the following function declaration:
                </p><pre class="programlisting">
gboolean
my_object_increment (MyObject *obj, gint32 x, gint32 *ret, GError **error);
                </pre><p>
              </p><p>
                This introspection XML:
                </p><pre class="programlisting">
&lt;method name="IncrementRetval"&gt;
  &lt;arg type="u" name="x" /&gt;
  &lt;arg type="u" direction="out" &gt;
    &lt;annotation name="org.freedesktop.DBus.GLib.ReturnVal" value=""/&gt;
  &lt;/arg&gt;
&lt;/method&gt;
                </pre><p>
                Expects the following function declaration:
                </p><pre class="programlisting">
gint32
my_object_increment_retval (MyObject *obj, gint32 x)
                </pre><p>
              </p><p>
                This introspection XML:
                </p><pre class="programlisting">
&lt;method name="IncrementRetvalError"&gt;
  &lt;arg type="u" name="x" /&gt;
  &lt;arg type="u" direction="out" &gt;
    &lt;annotation name="org.freedesktop.DBus.GLib.ReturnVal" value="error"/&gt;
  &lt;/arg&gt;
&lt;/method&gt;
                </pre><p>
                Expects the following function declaration:
                </p><pre class="programlisting">
gint32
my_object_increment_retval_error (MyObject *obj, gint32 x, GError **error)
                </pre><p>
              </p></dd></dl></div><p>
      </p></div></div><div class="sect1" title="Python API"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="python-client"></a>Python API</h2></div></div></div><p>
      The Python API, dbus-python, is now documented separately in
      <a class="ulink" href="http://dbus.freedesktop.org/doc/dbus-python/doc/tutorial.html" target="_top">the dbus-python tutorial</a> (also available in doc/tutorial.txt,
      and doc/tutorial.html if built with python-docutils, in the dbus-python
      source distribution).
    </p></div><div class="sect1" title="Qt API: Using Remote Objects"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="qt-client"></a>Qt API: Using Remote Objects</h2></div></div></div><p>
      
      The Qt bindings are not yet documented.

    </p></div><div class="sect1" title="Qt API: Implementing Objects"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="qt-server"></a>Qt API: Implementing Objects</h2></div></div></div><p>
      The Qt bindings are not yet documented.
    </p></div></div></body></html>
